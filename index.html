<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <!-- manifest.jsonì€ HTTPS ë˜ëŠ” localhostì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤ -->
    <script>
        // file:// í”„ë¡œí† ì½œì´ ì•„ë‹ ë•Œë§Œ manifest ë§í¬ ì¶”ê°€
        if (window.location.protocol !== 'file:') {
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = 'manifest.json';
            document.head.appendChild(link);
        }
    </script>
    <title>ğŸ“± AI ì—…ë¬´ ë‚´ë¹„ê²Œì´í„°</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #1a1a1a;
            --accent: #4a9eff;
            --success: #10b981;
            --white: #FFFFFF;
            --bg-light: #f8f9fa;
            --text-dark: #1a1a1a;
            --text-gray: #6c757d;
            --border-light: #dee2e6;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            font-family: -apple-system, 'Malgun Gothic', sans-serif;
            background: var(--bg-light);
            color: var(--text-dark);
            -webkit-font-smoothing: antialiased;
        }
        .header {
            background: linear-gradient(135deg, var(--primary), #2d2d2d);
            color: var(--white);
            padding: 15px 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: var(--shadow);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-title {
            font-size: 1.2rem;
            font-weight: 700;
        }
        .header-actions {
            display: flex;
            gap: 10px;
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            touch-action: manipulation;
        }
        .btn:active {
            transform: scale(0.95);
        }
        .btn-primary {
            background: var(--accent);
            color: var(--white);
        }
        .btn-secondary {
            background: #6c757d;
            color: var(--white);
        }
        .btn-success {
            background: var(--success);
            color: var(--white);
        }
        .btn-small {
            padding: 6px 10px;
            font-size: 0.8rem;
        }
        .main-content {
            padding: 20px;
            max-width: 100%;
        }
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-gray);
        }
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        .workflow-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .workflow-card {
            background: var(--white);
            border-radius: 12px;
            padding: 16px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .workflow-card:active {
            transform: scale(0.98);
        }
        .workflow-card.new-workflow {
            border: 2px solid var(--accent);
            background: linear-gradient(135deg, rgba(74, 158, 255, 0.05) 0%, rgba(74, 158, 255, 0.02) 100%);
        }
        .workflow-delete-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.1);
            border: none;
            color: #ef4444;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }
        .workflow-delete-btn:active {
            background: #ef4444;
            color: white;
            transform: scale(0.9);
        }
        .new-badge {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 700;
            margin-right: 8px;
        }
        .workflow-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-dark);
        }
        .workflow-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            font-size: 0.85rem;
            color: var(--text-gray);
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--success));
            transition: width 0.3s;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            opacity: 0;
            transition: opacity 0.18s ease-out;
        }
        .modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            opacity: 1;
        }
        .modal-content {
            background: var(--white);
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            margin: auto;
            transform: translateY(10px) scale(0.98);
            opacity: 0;
            transition: transform 0.18s ease-out, opacity 0.18s ease-out;
        }
        .modal.show .modal-content {
            transform: translateY(0) scale(1);
            opacity: 1;
        }
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--white);
            z-index: 10;
        }
        .modal-title {
            font-size: 1.2rem;
            font-weight: 700;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .close-btn:active {
            background: var(--bg-light);
        }
        .modal-body {
            padding: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-light);
            border-radius: 8px;
            font-size: 0.95rem;
            font-family: inherit;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
        }
        .checklist-item {
            background: var(--white);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }
        .checklist-item.completed {
            opacity: 0.6;
        }
        .checklist-item.skipped {
            opacity: 0.5;
            background: #f9fafb;
        }
        .checklist-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .checklist-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .checklist-text {
            flex: 1;
            font-size: 0.95rem;
        }
        .checklist-text.completed {
            text-decoration: line-through;
            color: var(--text-gray);
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: var(--white);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 2000;
            display: none;
            font-size: 0.9rem;
        }
        .toast.show {
            display: block;
            animation: slideUp 0.3s ease;
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-light);
            border-radius: 8px;
            cursor: pointer;
        }
        .radio-option input[type="radio"] {
            width: 20px;
            height: 20px;
        }
        .ai-guide-content {
            white-space: pre-wrap;
            line-height: 1.8;
            color: var(--text-dark);
            font-size: 0.95rem;
        }

        /* ===== AI ì—…ë¬´íŒŒíŠ¸ë„ˆ: FAB + Bottom Sheet ===== */
        .ai-fab {
            position: fixed;
            right: 16px;
            bottom: calc(16px + env(safe-area-inset-bottom, 0px));
            width: 56px;
            height: 56px;
            border-radius: 18px;
            border: none;
            background: linear-gradient(135deg, var(--accent), #2563eb);
            color: var(--white);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.35);
            z-index: 1500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 800;
            touch-action: manipulation;
            transition: opacity 0.18s ease, transform 0.18s ease;
        }
        .ai-fab.hidden {
            pointer-events: none;
            opacity: 0;
            transform: translateY(12px);
        }
        .ai-fab:active { transform: scale(0.96); }

        .bottomsheet-modal.show {
            align-items: flex-end;
            justify-content: center;
            padding: 0;
        }
        .bottomsheet-modal .modal-content {
            width: 100%;
            max-width: 500px;
            max-height: 92vh;
            height: 82vh;
            border-radius: 18px 18px 0 0;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            will-change: transform;
        }
        .bottomsheet-modal.show .modal-content {
            animation: bottomSheetUp 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }
        .bottomsheet-modal.closing .modal-content {
            animation: bottomSheetDown 0.25s cubic-bezier(0.55, 0.06, 0.68, 0.19) forwards;
        }
        @keyframes bottomSheetUp {
            from { 
                transform: translateY(100%);
            }
            to { 
                transform: translateY(0);
            }
        }
        @keyframes bottomSheetDown {
            from { 
                transform: translateY(0);
            }
            to { 
                transform: translateY(100%);
            }
        }

        .ai-sheet-header {
            padding: 14px 16px 10px 16px;
            border-bottom: 1px solid var(--border-light);
            background: var(--white);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .ai-sheet-handle {
            width: 44px;
            height: 5px;
            border-radius: 999px;
            background: #d1d5db;
            margin: 0 auto 10px auto;
            touch-action: none;
        }
        .ai-sheet-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .ai-sheet-title {
            font-size: 1.05rem;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ai-context-chip {
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            background: #f0f9ff;
            border: 1px solid rgba(59, 130, 246, 0.15);
            border-radius: 12px;
            font-size: 0.85rem;
            color: #0369a1;
        }
        .ai-context-chip label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 700;
        }
        .ai-context-chip input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .ai-chat {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0; /* allow chat box to shrink and scroll */
        }
        .ai-chat-box {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 14px 14px 10px 14px;
            background: var(--bg-light);
            min-height: 0;
        }
        /* ì²˜ìŒ ì•ˆë‚´ ë©”ì‹œì§€ë§Œ ìˆì„ ë•ŒëŠ” ê°€ìš´ë° ì •ë ¬ (Claude ìŠ¤íƒ€ì¼) */
        .ai-chat-box.ai-empty-state {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .ai-msg {
            display: flex;
            margin-bottom: 10px;
        }
        .ai-msg .bubble {
            max-width: 86%;
            padding: 10px 12px;
            border-radius: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.06);
            white-space: pre-wrap;
            line-height: 1.55;
            font-size: 0.92rem;
        }
        .ai-msg.user { justify-content: flex-end; }
        .ai-msg.user .bubble {
            background: linear-gradient(135deg, var(--accent), #2563eb);
            color: white;
            border-bottom-right-radius: 6px;
        }
        .ai-msg.assistant { justify-content: flex-start; }
        .ai-msg.assistant .bubble {
            background: white;
            color: var(--text-dark);
            border: 1px solid var(--border-light);
            border-bottom-left-radius: 6px;
        }
        .ai-msg.system .bubble {
            background: #111827;
            color: white;
            opacity: 0.92;
            border-radius: 12px;
            margin: 0 auto;
            max-width: 92%;
            font-size: 0.85rem;
        }

        /* ì²´í¬ë¦¬ìŠ¤íŠ¸ AI ê¸¸ì¡ì´ ëª¨ë‹¬ìš© ë§ˆí¬ë‹¤ìš´ ìŠ¤íƒ€ì¼ */
        .ai-guide-content {
            font-size: 0.92rem;
            line-height: 1.6;
        }
        .ai-guide-content .md h1,
        .ai-guide-content .md h2,
        .ai-guide-content .md h3 {
            margin: 8px 0 6px 0;
            line-height: 1.25;
            letter-spacing: -0.01em;
        }
        .ai-guide-content .md h1 { font-size: 1.05rem; }
        .ai-guide-content .md h2 { font-size: 1.0rem; }
        .ai-guide-content .md h3 { font-size: 0.97rem; }
        .ai-guide-content .md p {
            margin: 6px 0;
        }
        .ai-guide-content .md ul,
        .ai-guide-content .md ol {
            margin: 6px 0 6px 18px;
            padding: 0;
        }
        .ai-guide-content .md li {
            margin: 4px 0;
        }
        .ai-guide-content .md blockquote {
            margin: 8px 0;
            padding: 8px 10px;
            border-left: 4px solid rgba(74, 158, 255, 0.7);
            background: rgba(74, 158, 255, 0.06);
            border-radius: 10px;
        }
        .ai-guide-content .md code.md-inline-code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.88em;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(17, 24, 39, 0.06);
            border: 1px solid rgba(17, 24, 39, 0.08);
        }

        /* Markdown rendering inside AI bubbles */
        .bubble .md h1, .bubble .md h2, .bubble .md h3 {
            margin: 8px 0 6px 0;
            line-height: 1.25;
            letter-spacing: -0.01em;
        }
        .bubble .md h1 { font-size: 1.05rem; }
        .bubble .md h2 { font-size: 1.0rem; }
        .bubble .md h3 { font-size: 0.97rem; }
        .bubble .md p {
            margin: 6px 0;
            line-height: 1.6;
        }
        .bubble .md ul, .bubble .md ol {
            margin: 6px 0 6px 18px;
            padding: 0;
        }
        .bubble .md li { margin: 4px 0; }
        .bubble .md blockquote {
            margin: 8px 0;
            padding: 8px 10px;
            border-left: 4px solid rgba(74, 158, 255, 0.7);
            background: rgba(74, 158, 255, 0.06);
            border-radius: 10px;
            color: inherit;
        }
        .bubble .md a {
            color: var(--accent);
            text-decoration: underline;
            word-break: break-word;
        }
        .bubble .md code.md-inline-code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.88em;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(17, 24, 39, 0.06);
            border: 1px solid rgba(17, 24, 39, 0.08);
        }
        .ai-msg.user .bubble .md code.md-inline-code {
            background: rgba(255, 255, 255, 0.14);
            border-color: rgba(255, 255, 255, 0.22);
        }
        .bubble .md pre.md-code {
            margin: 10px 0;
            padding: 10px 12px;
            border-radius: 12px;
            background: #0b1220;
            color: #e5e7eb;
            overflow-x: auto;
            border: 1px solid rgba(255,255,255,0.08);
        }
        .bubble .md pre.md-code code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.86em;
            line-height: 1.55;
            white-space: pre;
        }
        .ai-msg.user .bubble .md a { color: #dbeafe; }
        .ai-msg.user .bubble .md blockquote {
            border-left-color: rgba(255,255,255,0.65);
            background: rgba(255,255,255,0.12);
        }
        .ai-chat-input {
            padding: 12px 12px calc(12px + env(safe-area-inset-bottom, 0px)) 12px;
            background: white;
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: 10px;
            align-items: flex-end;
            transition: box-shadow 0.16s ease-out;
        }
        .ai-chat-input.focused {
            box-shadow: 0 -4px 18px rgba(15, 23, 42, 0.16);
        }
        .ai-chat-input textarea {
            flex: 1;
            min-height: 42px;
            max-height: 120px;
            resize: none;
            padding: 10px 12px;
            border: 1px solid var(--border-light);
            border-radius: 12px;
            font-family: inherit;
            font-size: 0.95rem;
            outline: none;
        }
        .ai-chat-input textarea:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.12);
        }
    </style>
</head>
<body>
    <!-- í—¤ë” -->
    <div class="header">
        <div class="header-content">
            <div class="header-title">ğŸ“± AI ì—…ë¬´ ë‚´ë¹„ê²Œì´í„°</div>
            <div class="header-actions">
                <button class="btn btn-secondary btn-small" onclick="app.openModal('settingsModal')">âš™ï¸ API</button>
                <button class="btn btn-primary btn-small" onclick="app.importProjectPackage()">ğŸ“¦ ê°€ì ¸ì˜¤ê¸°</button>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ ì½˜í…ì¸  -->
    <div class="main-content">
        <div id="workflowList" class="workflow-list">
            <div class="empty-state">
                <div class="empty-state-icon">ğŸ“­</div>
                <div>ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤</div>
                <div style="margin-top: 10px; font-size: 0.9rem; color: var(--text-gray);">
                    ìƒë‹¨ì˜ [ğŸ“¦ ê°€ì ¸ì˜¤ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬<br>ì—…ë¬´ íŒ¨í‚¤ì§€ë¥¼ ê°€ì ¸ì˜¤ì„¸ìš”
                </div>
            </div>
        </div>
    </div>

    <!-- API ì„¤ì • ëª¨ë‹¬ -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">âš™ï¸ AI ì„¤ì •</div>
                <button class="close-btn" onclick="app.closeModal('settingsModal')">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">ğŸ”Œ AI ì„œë¹„ìŠ¤ ì„ íƒ</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="provider-gemini" name="provider" value="gemini" checked onchange="app.selectProvider('gemini')">
                            <label for="provider-gemini">âš¡ Gemini</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="provider-chatgpt" name="provider" value="chatgpt" onchange="app.selectProvider('chatgpt')">
                            <label for="provider-chatgpt">ğŸ¤– ChatGPT</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="provider-claude" name="provider" value="claude" onchange="app.selectProvider('claude')">
                            <label for="provider-claude">ğŸ§  Claude</label>
                        </div>
                    </div>
                </div>

                <div id="geminiSettings">
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ¤– ëª¨ë¸ ì„ íƒ
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (ì¶”ì²œ: Gemini 2.5 Flash)
                            </span>
                        </label>
                        <select class="form-select" id="geminiModelSelect" onchange="app.selectModel('gemini', this.value)">
                            <option value="gemini-2.5-flash">âš¡ Gemini 2.5 Flash (ì¶”ì²œ, ë¬´ë£Œë“±ê¸‰ 1ì¼ 20íšŒ)</option>
                            <option value="gemini-2.5-flash-lite">âš¡ Gemini 2.5 Flash Lite (ë¬´ë£Œë“±ê¸‰ 1ì¼ 20íšŒ)</option>
                            <option value="gemini-2.0-flash">ğŸš€ Gemini 2.0 Flash (ì¼ì¼ ë¬´ì œí•œ, RPM 2K)</option>
                            <option value="gemini-2.0-flash-lite">âš¡ Gemini 2.0 Flash Lite (ì¼ì¼ ë¬´ì œí•œ, RPM 4K)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ”‘ API Key
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (Google AI Studioì—ì„œ ë°œê¸‰)
                            </span>
                        </label>
                        <input type="password" class="form-input" id="geminiApiKeyInput" placeholder="AIzaë¡œ ì‹œì‘í•˜ëŠ” í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                            <span id="geminiApiKeyStatus" style="color: var(--text-gray);"></span>
                            <button class="btn btn-secondary btn-small" onclick="app.resetApiKeyInput('gemini')">ğŸ”‘ í‚¤ ë³€ê²½</button>
                        </div>
                    </div>
                </div>

                <div id="chatgptSettings" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ¤– ëª¨ë¸ ì„ íƒ
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (ë¹ ë¥¸ ì‘ì—…ìš©)
                            </span>
                        </label>
                        <select class="form-select" id="chatgptModelSelect" onchange="app.selectModel('chatgpt', this.value)">
                            <option value="gpt-4o-mini">âš¡ GPT-4o-mini (ë¹ ë¥¸ ì‘ì—…, ì¶”ì²œ)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ”‘ API Key
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (OpenAI Platformì—ì„œ ë°œê¸‰)
                            </span>
                        </label>
                        <input type="password" class="form-input" id="chatgptApiKeyInput" placeholder="sk-ë¡œ ì‹œì‘í•˜ëŠ” í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                            <span id="chatgptApiKeyStatus" style="color: var(--text-gray);"></span>
                            <button class="btn btn-secondary btn-small" onclick="app.resetApiKeyInput('chatgpt')">ğŸ”‘ í‚¤ ë³€ê²½</button>
                        </div>
                    </div>
                </div>

                <div id="claudeSettings" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ¤– ëª¨ë¸ ì„ íƒ
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (ë¹ ë¥¸ ì‘ì—… / ê³ ê¸‰ ë¶„ì„)
                            </span>
                        </label>
                        <select class="form-select" id="claudeModelSelect" onchange="app.selectModel('claude', this.value)">
                            <option value="claude-3-5-haiku-20241022">âš¡ Claude 3.5 Haiku (ë¹ ë¥¸ ì‘ì—…, ì¶”ì²œ)</option>
                            <option value="claude-sonnet-4-20250514">ğŸ§  Claude Sonnet 4 (ê³ ê¸‰ ë¶„ì„)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ”‘ API Key
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (Anthropic Consoleì—ì„œ ë°œê¸‰)
                            </span>
                        </label>
                        <input type="password" class="form-input" id="claudeApiKeyInput" placeholder="sk-ant-ë¡œ ì‹œì‘í•˜ëŠ” í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                            <span id="claudeApiKeyStatus" style="color: var(--text-gray);"></span>
                            <button class="btn btn-secondary btn-small" onclick="app.resetApiKeyInput('claude')">ğŸ”‘ í‚¤ ë³€ê²½</button>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 24px; padding-top: 20px; border-top: 2px solid var(--border-light);">
                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                        <button class="btn btn-success" style="flex: 1;" onclick="app.saveApiKey()">ğŸ’¾ ì €ì¥</button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="app.testApiConnection()">ğŸ§ª ì—°ê²° í…ŒìŠ¤íŠ¸</button>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--text-gray); text-align: center; line-height: 1.5;">
                        âœ… API í‚¤ëŠ” ë¡œì»¬ì— ì•ˆì „í•˜ê²Œ ì €ì¥ë©ë‹ˆë‹¤<br>
                        ğŸ’¡ ë¨¼ì € [ì—°ê²° í…ŒìŠ¤íŠ¸]ë¡œ í™•ì¸ í›„ [ì €ì¥]í•˜ì„¸ìš”
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ì²´í¬ë¦¬ìŠ¤íŠ¸ ë³´ê¸° ëª¨ë‹¬ -->
    <div class="modal" id="checklistModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="checklistModalTitle">ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸</div>
                <button class="close-btn" onclick="app.closeModal('checklistModal')">Ã—</button>
            </div>
            <div class="modal-body" id="checklistModalBody">
                <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
            </div>
        </div>
    </div>

    <!-- AI ê¸¸ì•ˆë‚´ ëª¨ë‹¬ -->
    <div class="modal" id="aiGuideModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ğŸ’¡ AI ê¸¸ì¡ì´</div>
                <button class="close-btn" onclick="app.closeModal('aiGuideModal')">Ã—</button>
            </div>
            <div class="modal-body">
                <div id="aiGuideContent" class="ai-guide-content">
                    <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                </div>
            </div>
        </div>
    </div>

    <!-- AI ì—…ë¬´íŒŒíŠ¸ë„ˆ FAB -->
    <button class="ai-fab" id="aiFab" onclick="app.openAiPartner()" aria-label="AI ì—…ë¬´íŒŒíŠ¸ë„ˆ ì—´ê¸°" title="AI ì—…ë¬´íŒŒíŠ¸ë„ˆ">
        ğŸ¤–
    </button>

    <!-- AI ì—…ë¬´íŒŒíŠ¸ë„ˆ Bottom Sheet -->
    <div class="modal bottomsheet-modal" id="aiPartnerModal">
        <div class="modal-content" id="aiPartnerSheet">
            <div class="ai-sheet-header" id="aiPartnerHeader">
                <div class="ai-sheet-handle" id="aiPartnerHandle"></div>
                <div class="ai-sheet-title-row">
                    <div class="ai-sheet-title">ğŸ¤– AI ì—…ë¬´íŒŒíŠ¸ë„ˆ</div>
                    <button class="close-btn" onclick="app.closeAiPartner()" aria-label="ë‹«ê¸°">Ã—</button>
                </div>
                <div class="ai-context-chip">
                    <label>
                        <input type="checkbox" id="aiUseWorkflowContext" />
                        <span>ğŸ“‹ í˜„ì¬ ì—…ë¬´ ì°¸ì¡°</span>
                    </label>
                    <div id="aiContextTitle" style="flex: 1; text-align: right; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>
                </div>
            </div>

            <div class="ai-chat">
                <div class="ai-chat-box" id="aiChatBox"></div>
                <div class="ai-chat-input">
                    <textarea id="aiChatInput" placeholder="AIì—ê²Œ ì§ˆë¬¸í•˜ê¸°..." rows="2"></textarea>
                    <button class="btn btn-success" id="aiChatSendBtn" style="padding: 10px 14px;">ğŸ“¤</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast ì•Œë¦¼ -->
    <div class="toast" id="toast"></div>

    <script>
        // IndexedDB ê´€ë¦¬ í´ë˜ìŠ¤
        class IndexedDBManager {
            constructor() {
                this.dbName = 'WorkflowDB';
                this.version = 2;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('projectFiles')) {
                            const projectStore = db.createObjectStore('projectFiles', { keyPath: 'id', autoIncrement: true });
                            projectStore.createIndex('projectKey', 'projectKey', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('formFiles')) {
                            const formStore = db.createObjectStore('formFiles', { keyPath: 'id', autoIncrement: true });
                            formStore.createIndex('detailKey', 'detailKey', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('projects')) {
                            const projectStore = db.createObjectStore('projects', { keyPath: 'id' });
                            projectStore.createIndex('title', 'title', { unique: false });
                            projectStore.createIndex('createdAt', 'createdAt', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('checklistDetails')) {
                            const detailStore = db.createObjectStore('checklistDetails', { keyPath: 'key' });
                            detailStore.createIndex('projectId', 'projectId', { unique: false });
                        }

                        if (!db.objectStoreNames.contains('pdfDocuments')) {
                            const pdfStore = db.createObjectStore('pdfDocuments', { keyPath: 'id', autoIncrement: true });
                            pdfStore.createIndex('projectId', 'projectId', { unique: false });
                            pdfStore.createIndex('fileName', 'fileName', { unique: false });
                            pdfStore.createIndex('parsedAt', 'parsedAt', { unique: false });
                        }
                    };
                });
            }

            async saveProject(project) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                if (!project.id) throw new Error('ì—…ë¬´ IDê°€ í•„ìš”í•©ë‹ˆë‹¤');
                
                project.updatedAt = new Date().toISOString();
                if (!project.createdAt) project.createdAt = project.updatedAt;
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    const request = store.put(project);
                    request.onsuccess = () => resolve(project.id);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllProjects() {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['projects'], 'readonly');
                    const store = transaction.objectStore('projects');
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveFile(storeName, fileData) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add(fileData);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getProjectFilesByProjectKey(projectKey) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                if (!projectKey) return [];

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['projectFiles'], 'readonly');
                    const store = transaction.objectStore('projectFiles');
                    const index = store.index('projectKey');
                    const request = index.getAll(projectKey);
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveChecklistDetails(key, details) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['checklistDetails'], 'readwrite');
                    const store = transaction.objectStore('checklistDetails');
                    const request = store.put({ key, ...details });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getChecklistDetails(key) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['checklistDetails'], 'readonly');
                    const store = transaction.objectStore('checklistDetails');
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(request.error);
                });
            }

            async getPdfDocumentsByProject(projectId) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['pdfDocuments'], 'readonly');
                    const store = transaction.objectStore('pdfDocuments');
                    const index = store.index('projectId');
                    const request = index.getAll(projectId);
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // ëª¨ë°”ì¼ ì—…ë¬´ ê´€ë¦¬ì
        class MobileWorkflowManager {
            constructor() {
                this.API_KEY_STORAGE = 'apiKeys_v5.1';
                this.allData = {
                    workflows: [],
                    provider: 'gemini',
                    geminiApiKey: '',
                    chatgptApiKey: '',
                    claudeApiKey: '',
                    selectedModel: {
                        gemini: 'gemini-2.5-flash',
                        chatgpt: 'gpt-4o-mini',
                        claude: 'claude-3-5-haiku-20241022'
                    }
                };
                this.checklistDetails = {};
                this.dbManager = new IndexedDBManager();
                this.tempImportData = null;
                this.currentWorkflowId = null;
                this.currentItemIndex = null;
                this.lastImportedWorkflowIds = []; // ìµœê·¼ ê°€ì ¸ì˜¨ ì—…ë¬´ ID ëª©ë¡

                // AI ì—…ë¬´íŒŒíŠ¸ë„ˆ (Bottom Sheet Chat)
                this.aiPartnerMessages = [];
                this.aiPartnerBusy = false;
                this.init();
            }

            async init() {
                try {
                    await this.dbManager.init();
                    await this.loadData();
                    await this.loadApiKeys();
                    this.displayWorkflows();
                    this.initAiPartnerUI();
                } catch (error) {
                    console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ì´ˆê¸°í™” ì‹¤íŒ¨: ' + error.message);
                }
            }

            async loadData() {
                try {
                    const projects = await this.dbManager.getAllProjects();
                    this.allData.workflows = projects;
                    
                    // ì²´í¬ë¦¬ìŠ¤íŠ¸ ì„¸ë¶€ ì •ë³´ ë¡œë“œ
                    for (const workflow of projects) {
                        const projectKey = `project-${workflow.id}`;
                        const details = await this.dbManager.getChecklistDetails(projectKey);
                        if (details) {
                            this.checklistDetails[projectKey] = details;
                        }
                    }
                } catch (error) {
                    console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                }
            }

            async loadApiKeys() {
                const apiKeys = localStorage.getItem(this.API_KEY_STORAGE);
                if (apiKeys) {
                    try {
                        const keys = JSON.parse(apiKeys);
                        // ì•”í˜¸í™”ëœ í‚¤ ë³µí˜¸í™”
                        this.allData.geminiApiKey = await this.decryptApiKey(keys.gemini || '');
                        this.allData.chatgptApiKey = await this.decryptApiKey(keys.chatgpt || '');
                        this.allData.claudeApiKey = await this.decryptApiKey(keys.claude || '');
                    } catch (e) {
                        console.error('API í‚¤ ë¡œë“œ ì˜¤ë¥˜:', e);
                    }
                }
                
                const appSettings = localStorage.getItem('appSettings_v5.2');
                if (appSettings) {
                    try {
                        const settings = JSON.parse(appSettings);
                        if (settings.provider) this.allData.provider = settings.provider;
                        if (settings.selectedModel) this.allData.selectedModel = settings.selectedModel;
                    } catch (e) {
                        console.error('ì„¤ì • ë¡œë“œ ì˜¤ë¥˜:', e);
                    }
                }
                
                this.updateApiKeyInputs();
            }

            updateApiKeyInputs() {
                const provider = this.allData.provider;
                document.getElementById('provider-' + provider).checked = true;
                this.selectProvider(provider);
                
                const geminiInput = document.getElementById('geminiApiKeyInput');
                const chatgptInput = document.getElementById('chatgptApiKeyInput');
                const claudeInput = document.getElementById('claudeApiKeyInput');
                
                if (geminiInput) {
                    geminiInput.value = this.allData.geminiApiKey ? 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.' : '';
                }
                if (chatgptInput) {
                    chatgptInput.value = this.allData.chatgptApiKey ? 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.' : '';
                }
                if (claudeInput) {
                    claudeInput.value = this.allData.claudeApiKey ? 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.' : '';
                }
            }

            displayWorkflows() {
                const container = document.getElementById('workflowList');
                if (!container) return;

                if (this.allData.workflows.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“­</div>
                            <div>ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤</div>
                            <div style="margin-top: 10px; font-size: 0.9rem; color: var(--text-gray);">
                                ìƒë‹¨ì˜ [ğŸ“¦ ê°€ì ¸ì˜¤ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬<br>ì—…ë¬´ íŒ¨í‚¤ì§€ë¥¼ ê°€ì ¸ì˜¤ì„¸ìš”
                            </div>
                        </div>
                    `;
                    return;
                }

                // ì—…ë¬´ ì •ë ¬: ìµœê·¼ ê°€ì ¸ì˜¨ ì—…ë¬´ê°€ ìƒë‹¨ì—
                const sortedWorkflows = [...this.allData.workflows].sort((a, b) => {
                    const importA = a.importedAt ? new Date(a.importedAt).getTime() : 0;
                    const importB = b.importedAt ? new Date(b.importedAt).getTime() : 0;
                    
                    // ë‘˜ ë‹¤ ê°€ì ¸ì˜¨ ê¸°ë¡ì´ ì—†ìœ¼ë©´ ìµœì‹ ìˆœ(ì‘ì„±ì¼)ìœ¼ë¡œ 2ì°¨ ì •ë ¬
                    if (importA === 0 && importB === 0) {
                        const dateA = a.createdAt ? new Date(a.createdAt) : new Date(a.date || 0);
                        const dateB = b.createdAt ? new Date(b.createdAt) : new Date(b.date || 0);
                        return dateB - dateA;
                    }
                    return importB - importA;
                });

                container.innerHTML = sortedWorkflows.map(workflow => {
                    const progress = this.calculateProgress(workflow);
                    const checklistCount = workflow.checklist ? workflow.checklist.length : 0;
                    const completedCount = workflow.checklist ? workflow.checklist.filter(c => 
                        this.normalizeCompleted(c) || c.skipped === true
                    ).length : 0;
                    const isNew = this.lastImportedWorkflowIds.includes(workflow.id);
                    const cardClass = isNew ? 'workflow-card new-workflow' : 'workflow-card';
                    const newBadge = isNew ? '<span class="new-badge">NEW</span>' : '';
                    
                    return `
                        <div class="${cardClass}" onclick="app.showChecklist(${workflow.id})">
                            <button class="workflow-delete-btn" onclick="event.stopPropagation(); app.deleteWorkflow(${workflow.id})" title="ì‚­ì œ">ğŸ—‘ï¸</button>
                            <div class="workflow-title">${newBadge}${this.escapeHtml(workflow.title)}</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <div class="workflow-meta">
                                <span>âœ… ${completedCount}/${checklistCount}</span>
                                <span>${progress}%</span>
                                <span>${workflow.date || ''}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            calculateProgress(workflow) {
                if (!workflow.checklist || workflow.checklist.length === 0) {
                    return workflow.completedDate ? 100 : 0;
                }
                // ê±´ë„ˆë›´ í•­ëª©ë„ ì™„ë£Œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼í•˜ì—¬ ì§„í–‰ë¥ ì— í¬í•¨
                const completed = workflow.checklist.filter(item => 
                    this.normalizeCompleted(item) || item.skipped === true
                ).length;
                return Math.round((completed / workflow.checklist.length) * 100);
            }

            normalizeCompleted(item) {
                if (item.completed === true || item.completed === 'true') return true;
                if (item.completed === false || item.completed === 'false') return false;
                return false;
            }

            showChecklist(workflowId) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow) return;

                this.currentWorkflowId = workflowId;

                // ì—…ë¬´ë¥¼ ì„ íƒí•˜ë©´ AI ì—…ë¬´íŒŒíŠ¸ë„ˆì˜ "í˜„ì¬ ì—…ë¬´ ì°¸ì¡°"ë¥¼ ìë™ í™œì„±í™”
                this.enableAiPartnerWorkflowContext();
                this.updateAiPartnerContextUI();
                const title = document.getElementById('checklistModalTitle');
                const body = document.getElementById('checklistModalBody');
                
                if (title) title.textContent = `ğŸ“‹ ${this.escapeHtml(workflow.title)}`;
                
                if (!workflow.checklist || workflow.checklist.length === 0) {
                    if (body) {
                        body.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-gray);">ì²´í¬ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                    }
                } else {
                    if (body) {
                        body.innerHTML = workflow.checklist.map((item, index) => {
                            // completed ìƒíƒœë¥¼ booleanìœ¼ë¡œ í™•ì‹¤íˆ ë³€í™˜
                            const isCompleted = Boolean(this.normalizeCompleted(item));
                            const isSkipped = item.skipped === true;
                            const itemNumber = index + 1;
                            
                            // ëª¨ë°”ì¼ì—ì„œëŠ” ë¶„ê¸° ë²„íŠ¼ì„ í‘œì‹œí•˜ì§€ ì•ŠìŒ (ë°ìŠ¤í¬íƒ‘ì—ì„œ ì„¤ì •í•œ ë¶„ê¸° ê²°ê³¼ë§Œ í‘œì‹œ)
                            let branchButtons = '';
                            
                            // ê±´ë„ˆë›´ í•­ëª© í‘œì‹œ (ë°ìŠ¤í¬íƒ‘ì—ì„œ ì„¤ì •í•œ ë¶„ê¸° ê²°ê³¼ëŠ” í‘œì‹œ)
                            const skipInfo = isSkipped ? `<div style="font-size: 0.8rem; color: #ef4444; margin-top: 4px;">ğŸš« ê±´ë„ˆëœ€${item.skipReason ? ': ' + this.escapeHtml(item.skipReason) : ''}</div>` : '';
                            
                            // ëª¨ë°”ì¼ì—ì„œëŠ” ì‹¤í–‰ì·¨ì†Œ ë²„íŠ¼ì„ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                            const undoButton = '';
                            
                            return `
                                <div class="checklist-item ${isCompleted ? 'completed' : ''} ${isSkipped ? 'skipped' : ''}" style="${isSkipped ? 'opacity: 0.6;' : ''}">
                                    <div class="checklist-item-header">
                                        ${isSkipped ? 
                                            '<span style="font-size: 1.2rem; color: #9ca3af; width: 30px; text-align: center;">ğŸš«</span>' :
                                            `<input type="checkbox" class="checklist-checkbox" ${isCompleted ? 'checked' : ''} 
                                                   onchange="app.toggleChecklistItem(${workflowId}, ${index})">`
                                        }
                                        <span style="font-weight: 600; color: var(--accent); min-width: 30px; font-size: 0.9rem;">[${itemNumber}]</span>
                                        <span class="checklist-text ${isCompleted ? 'completed' : ''}" style="flex: 1;">
                                            ${this.escapeHtml(item.text || '')}
                                        </span>
                                        ${!isSkipped ? `
                                            <button class="btn btn-primary btn-small" onclick="event.stopPropagation(); app.showAIGuide(${workflowId}, ${index})" style="padding: 6px 10px; font-size: 0.8rem;">
                                                ğŸ’¡ AI
                                            </button>
                                        ` : ''}
                                    </div>
                                    ${skipInfo}
                                    ${branchButtons}
                                    ${undoButton}
                                </div>
                            `;
                        }).join('');
                    }
                }
                
                this.openModal('checklistModal');
            }

            enableAiPartnerWorkflowContext() {
                const wf = this.getCurrentWorkflow();
                const useContext = document.getElementById('aiUseWorkflowContext');
                if (!useContext) return;

                if (!wf) {
                    useContext.checked = false;
                    return;
                }

                // ìš”ì²­ì‚¬í•­: ì—…ë¬´ ì„ íƒ ì‹œ ìë™ìœ¼ë¡œ ì²´í¬(í™œì„±í™”)
                useContext.checked = true;
            }

            /* ===== AI ì—…ë¬´íŒŒíŠ¸ë„ˆ: UI/ë™ì‘ ===== */
            initAiPartnerUI() {
                const modal = document.getElementById('aiPartnerModal');
                const sendBtn = document.getElementById('aiChatSendBtn');
                const input = document.getElementById('aiChatInput');
                const useContext = document.getElementById('aiUseWorkflowContext');
                const handle = document.getElementById('aiPartnerHandle');
                const sheet = document.getElementById('aiPartnerSheet');

                if (!modal || !sendBtn || !input || !useContext || !handle || !sheet) return;

                // ê¸°ë³¸ ë©”ì‹œì§€
                if (this.aiPartnerMessages.length === 0) {
                    this.aiPartnerMessages.push({
                        role: 'system',
                        text: 'ì•ˆë…•í•˜ì„¸ìš”! AI ì—…ë¬´íŒŒíŠ¸ë„ˆì…ë‹ˆë‹¤.\nì—…ë¬´ ì§„í–‰ ì¤‘ ë§‰íˆëŠ” ë¶€ë¶„ì„ ì§ˆë¬¸í•˜ê±°ë‚˜, ë‹¤ìŒ í–‰ë™ì„ ë¬¼ì–´ë³´ì„¸ìš”.'
                    });
                    this.renderAiPartnerMessages();
                }

                // ì˜¤ë²„ë ˆì´ í´ë¦­ ë‹«ê¸°
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) this.closeAiPartner();
                });

                // ì „ì†¡ ë²„íŠ¼
                sendBtn.addEventListener('click', () => this.sendAiPartnerMessage());

                // ì…ë ¥ í¬ì»¤ìŠ¤ ì‹œ í•˜ë‹¨ ì…ë ¥ ì˜ì—­ì—ë§Œ ì‚´ì§ ê·¸ë¦¼ì (ë ˆì´ì•„ì›ƒ ë³€í™” ì—†ìŒ)
                const inputContainer = input.closest('.ai-chat-input');
                if (inputContainer) {
                    input.addEventListener('focus', () => {
                        inputContainer.classList.add('focused');
                    });
                    input.addEventListener('blur', () => {
                        inputContainer.classList.remove('focused');
                    });
                }

                // ì—”í„° ì „ì†¡ (ëª¨ë°”ì¼ì—ì„œëŠ” Shift+Enter ì¤„ë°”ê¿ˆ)
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendAiPartnerMessage();
                    }
                });

                // ì»¨í…ìŠ¤íŠ¸ í† ê¸€ ë³€ê²½ ì‹œ ì•ˆë‚´
                useContext.addEventListener('change', () => {
                    if (useContext.checked) {
                        const wf = this.getCurrentWorkflow();
                        if (!wf) {
                            useContext.checked = false;
                            this.showToast('error', 'âš ï¸', 'ì°¸ì¡°í•  ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ì—¬ì„¸ìš”.');
                        }
                    }
                });

                // ë“œë˜ê·¸ë¡œ ë‹«ê¸°
                let dragging = false;
                let startY = 0;
                let currentY = 0;
                const onPointerDown = (e) => {
                    dragging = true;
                    startY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
                    currentY = 0;
                    sheet.style.transition = 'none';
                };
                const onPointerMove = (e) => {
                    if (!dragging) return;
                    const y = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
                    currentY = Math.max(0, y - startY);
                    sheet.style.transform = `translateY(${currentY}px)`;
                };
                const onPointerUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    sheet.style.transition = 'transform 0.18s ease';
                    if (currentY > 120) {
                        sheet.style.transform = '';
                        this.closeAiPartner();
                    } else {
                        sheet.style.transform = '';
                    }
                };

                handle.addEventListener('pointerdown', onPointerDown);
                window.addEventListener('pointermove', onPointerMove);
                window.addEventListener('pointerup', onPointerUp);

                // ì´ˆê¸° ì»¨í…ìŠ¤íŠ¸ UI
                this.updateAiPartnerContextUI();
            }

            openAiPartner() {
                this.updateAiPartnerContextUI();
                
                const modal = document.getElementById('aiPartnerModal');
                const sheet = document.getElementById('aiPartnerSheet');
                
                if (modal && sheet) {
                    // ëª¨ë‹¬ì´ ì—´ë¦¬ê¸° ì „ ì´ˆê¸° ìƒíƒœë¥¼ ëª…í™•íˆ ì„¤ì • (ê¹œë°•ì„ ë°©ì§€)
                    sheet.style.transform = 'translateY(100%)';
                    sheet.style.willChange = 'transform';
                    
                    // ëª¨ë‹¬ í‘œì‹œ
                    this.openModal('aiPartnerModal');
                    
                    // ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ë¶€ë“œëŸ¬ìš´ ì „í™˜ ë³´ì¥)
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // CSS ì• ë‹ˆë©”ì´ì…˜ì´ ì ìš©ë˜ë„ë¡ í´ë˜ìŠ¤ ì¬ì ìš©
                            modal.classList.remove('show');
                            void modal.offsetWidth; // ë¦¬í”Œë¡œìš° ê°•ì œ
                            modal.classList.add('show');
                        });
                    });
                } else {
                    this.openModal('aiPartnerModal');
                }
                
                // ìŠ¤í¬ë¡¤ê³¼ í¬ì»¤ìŠ¤ëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ì‹œì‘ëœ í›„ì— ì‹¤í–‰
                setTimeout(() => {
                    this.scrollAiChatToBottom();
                    const input = document.getElementById('aiChatInput');
                    if (input) setTimeout(() => input.focus(), 100);
                }, 50);

                // FABê°€ ëª¨ë‹¬ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ìˆ¨ê¸°ê¸°
                const fab = document.getElementById('aiFab');
                if (fab) {
                    fab.classList.add('hidden');
                }
            }

            closeAiPartner() {
                const modal = document.getElementById('aiPartnerModal');
                if (!modal) {
                    this.closeModal('aiPartnerModal');
                    return;
                }
                modal.classList.add('closing');
                setTimeout(() => {
                    modal.classList.remove('closing');
                    this.closeModal('aiPartnerModal');

                    // ëª¨ë‹¬ì´ ì™„ì „íˆ ë‹«íŒ í›„ FAB ë‹¤ì‹œ í‘œì‹œ
                    const fab = document.getElementById('aiFab');
                    if (fab) {
                        fab.classList.remove('hidden');
                    }
                }, 190);
            }

            getCurrentWorkflow() {
                if (!this.currentWorkflowId) return null;
                return this.allData.workflows.find(w => w.id === this.currentWorkflowId) || null;
            }

            updateAiPartnerContextUI() {
                const useContext = document.getElementById('aiUseWorkflowContext');
                const titleEl = document.getElementById('aiContextTitle');
                if (!useContext || !titleEl) return;

                const wf = this.getCurrentWorkflow();
                if (!wf) {
                    useContext.checked = false;
                    useContext.disabled = true;
                    titleEl.textContent = 'ì—…ë¬´ ì„ íƒ ì—†ìŒ';
                    titleEl.style.opacity = '0.7';
                    return;
                }

                useContext.disabled = false;
                titleEl.textContent = wf.title ? String(wf.title) : 'í˜„ì¬ ì—…ë¬´';
                titleEl.style.opacity = '1';
            }

            renderAiPartnerMessages() {
                const box = document.getElementById('aiChatBox');
                if (!box) return;

                // Claude ìŠ¤íƒ€ì¼: ì²˜ìŒ ì•ˆë‚´(system) ë©”ì‹œì§€ë§Œ ìˆì„ ë•ŒëŠ” ê°€ìš´ë° ì •ë ¬
                const onlySystem =
                    this.aiPartnerMessages.length === 1 &&
                    (this.aiPartnerMessages[0].role || 'assistant') === 'system';
                if (onlySystem) {
                    box.classList.add('ai-empty-state');
                } else {
                    box.classList.remove('ai-empty-state');
                }

                box.innerHTML = this.aiPartnerMessages.map(m => {
                    const role = m.role || 'assistant';
                    const text = (m.text || '').toString();
                    const html = role === 'user'
                        ? this.escapeHtml(text).replace(/\n/g, '<br>')
                        : this.renderMarkdownToHtml(text);
                    return `<div class="ai-msg ${role}"><div class="bubble"><div class="md">${html}</div></div></div>`;
                }).join('');

                this.scrollAiChatToBottom();
            }

            // ì•ˆì „í•œ(HTML escape ê¸°ë°˜) ë§ˆí¬ë‹¤ìš´ ë Œë”ëŸ¬: í—¤ë”©/ë¦¬ìŠ¤íŠ¸/êµµê²Œ/ì¸ë¼ì¸ì½”ë“œ/ì½”ë“œë¸”ë¡/ë§í¬/ì¸ìš©
            renderMarkdownToHtml(markdownText) {
                const raw = (markdownText || '').toString();

                // 1) HTML escape
                let escaped = this.escapeHtml(raw);

                // 2) ì½”ë“œë¸”ë¡ ``` ... ``` (ê°€ì¥ ë¨¼ì € ì²˜ë¦¬)
                // escaped ìƒíƒœì—ì„œë„ ``` ëŠ” ê·¸ëŒ€ë¡œì´ë¯€ë¡œ ì •ê·œì‹ ì ìš© ê°€ëŠ¥
                escaped = escaped.replace(/```([\s\S]*?)```/g, (match, code) => {
                    const trimmed = (code || '').replace(/^\n+|\n+$/g, '');
                    return `\n\n<pre class="md-code"><code>${trimmed}</code></pre>\n\n`;
                });

                // 3) ì¸ë¼ì¸ ì½”ë“œ `...`
                escaped = escaped.replace(/`([^`\n]+)`/g, (m, code) => {
                    return `<code class="md-inline-code">${code}</code>`;
                });

                // 4) ë§í¬ [text](url) - http(s)ë§Œ í—ˆìš©
                escaped = escaped.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, url) => {
                    const u = (url || '').trim();
                    const safeUrl = (u.startsWith('http://') || u.startsWith('https://')) ? u : '';
                    if (!safeUrl) return `${text} (${url})`;
                    return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${text}</a>`;
                });

                // 5) êµµê²Œ **text**
                escaped = escaped.replace(/\*\*([^*]+)\*\*/g, (m, t) => `<strong>${t}</strong>`);

                // 6) ë¼ì¸ ë‹¨ìœ„ íŒŒì‹±(í—¤ë”©/ë¦¬ìŠ¤íŠ¸/ì¸ìš©/ë¬¸ë‹¨)
                const lines = escaped.split(/\r?\n/);
                const out = [];
                let inUl = false;
                let inOl = false;
                let inQuote = false;

                const closeLists = () => {
                    if (inUl) { out.push('</ul>'); inUl = false; }
                    if (inOl) { out.push('</ol>'); inOl = false; }
                };
                const closeQuote = () => {
                    if (inQuote) { out.push('</blockquote>'); inQuote = false; }
                };

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();

                    // ì´ë¯¸ HTML ë¸”ë¡(ì½”ë“œë¸”ë¡ pre)ì´ ë“¤ì–´ê°„ ë¼ì¸: ê·¸ëŒ€ë¡œ ì¶œë ¥í•˜ë˜ ë¬¸ë§¥ ì •ë¦¬
                    if (trimmed.startsWith('<pre class="md-code">')) {
                        closeLists();
                        closeQuote();
                        out.push(line);
                        continue;
                    }

                    // ë¹ˆ ì¤„ => ë¸”ë¡ ì¢…ë£Œ
                    if (!trimmed) {
                        closeLists();
                        closeQuote();
                        continue;
                    }

                    // í—¤ë”©
                    const h3 = trimmed.match(/^###\s+(.*)$/);
                    const h2 = trimmed.match(/^##\s+(.*)$/);
                    const h1 = trimmed.match(/^#\s+(.*)$/);
                    if (h3 || h2 || h1) {
                        closeLists();
                        closeQuote();
                        if (h3) out.push(`<h3>${h3[1]}</h3>`);
                        else if (h2) out.push(`<h2>${h2[1]}</h2>`);
                        else out.push(`<h1>${h1[1]}</h1>`);
                        continue;
                    }

                    // ì¸ìš©
                    const quote = trimmed.match(/^>\s?(.*)$/);
                    if (quote) {
                        closeLists();
                        if (!inQuote) {
                            out.push('<blockquote>');
                            inQuote = true;
                        }
                        out.push(`<p>${quote[1]}</p>`);
                        continue;
                    } else {
                        closeQuote();
                    }

                    // UL: - item / * item
                    const ul = trimmed.match(/^[-*]\s+(.*)$/);
                    if (ul) {
                        if (inOl) { out.push('</ol>'); inOl = false; }
                        if (!inUl) { out.push('<ul>'); inUl = true; }
                        out.push(`<li>${ul[1]}</li>`);
                        continue;
                    }

                    // OL: 1. item
                    const ol = trimmed.match(/^\d+\.\s+(.*)$/);
                    if (ol) {
                        if (inUl) { out.push('</ul>'); inUl = false; }
                        if (!inOl) { out.push('<ol>'); inOl = true; }
                        out.push(`<li>${ol[1]}</li>`);
                        continue;
                    }

                    // ì¼ë°˜ ë¬¸ë‹¨
                    closeLists();
                    out.push(`<p>${trimmed}</p>`);
                }

                closeLists();
                closeQuote();

                return out.join('\n');
            }

            scrollAiChatToBottom() {
                const box = document.getElementById('aiChatBox');
                if (!box) return;
                box.scrollTop = box.scrollHeight;
            }

            async sendAiPartnerMessage() {
                if (this.aiPartnerBusy) return;

                const input = document.getElementById('aiChatInput');
                const useContext = document.getElementById('aiUseWorkflowContext');
                const sendBtn = document.getElementById('aiChatSendBtn');

                if (!input || !useContext || !sendBtn) return;

                const text = (input.value || '').trim();
                if (!text) return;

                // API í‚¤ ì²´í¬ (showAIGuideì™€ ë™ì¼í•œ UX)
                const provider = this.allData.provider;
                const apiKey = provider === 'gemini' ? this.allData.geminiApiKey
                    : provider === 'chatgpt' ? this.allData.chatgptApiKey
                    : provider === 'claude' ? this.allData.claudeApiKey
                    : '';

                if (!apiKey) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”');
                    this.openModal('settingsModal');
                    return;
                }

                input.value = '';

                this.aiPartnerMessages.push({ role: 'user', text });
                this.aiPartnerMessages.push({ role: 'assistant', text: 'ìƒê° ì¤‘â€¦' });
                this.renderAiPartnerMessages();

                this.aiPartnerBusy = true;
                sendBtn.disabled = true;

                try {
                    const prompt = await this.buildAiPartnerPrompt(text, useContext.checked === true);
                    const answer = await this.callAI(prompt);

                    // ë§ˆì§€ë§‰ assistant(placeholder) êµì²´
                    const lastIdx = this.aiPartnerMessages.length - 1;
                    if (this.aiPartnerMessages[lastIdx] && this.aiPartnerMessages[lastIdx].role === 'assistant') {
                        this.aiPartnerMessages[lastIdx].text = answer;
                    } else {
                        this.aiPartnerMessages.push({ role: 'assistant', text: answer });
                    }

                    this.renderAiPartnerMessages();
                } catch (error) {
                    // placeholder êµì²´
                    const lastIdx = this.aiPartnerMessages.length - 1;
                    if (this.aiPartnerMessages[lastIdx] && this.aiPartnerMessages[lastIdx].role === 'assistant') {
                        this.aiPartnerMessages[lastIdx].text = `í˜¸ì¶œ ì‹¤íŒ¨: ${error.message}`;
                    } else {
                        this.aiPartnerMessages.push({ role: 'assistant', text: `í˜¸ì¶œ ì‹¤íŒ¨: ${error.message}` });
                    }
                    this.renderAiPartnerMessages();
                    this.showToast('error', 'âŒ', 'AI í˜¸ì¶œ ì‹¤íŒ¨: ' + error.message);
                } finally {
                    this.aiPartnerBusy = false;
                    sendBtn.disabled = false;
                }
            }

            async buildAiPartnerPrompt(userText, useWorkflowContext) {
                const provider = this.allData.provider;
                const model = this.allData.selectedModel && this.allData.selectedModel[provider] ? this.allData.selectedModel[provider] : '';

                // API í‚¤(ë¬¸ì„œ ì»¨í…ìŠ¤íŠ¸ ìƒì„±ì— í•„ìš”í•  ìˆ˜ë„ ìˆìŒ - getSmartDocContextëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ìš”ì•½/ì¶”ì¶œì´ë¼ í‚¤ ì—†ì–´ë„ ë™ì‘)
                const apiKey = provider === 'gemini' ? this.allData.geminiApiKey
                    : provider === 'chatgpt' ? this.allData.chatgptApiKey
                    : provider === 'claude' ? this.allData.claudeApiKey
                    : '';

                const truncate = (text, maxLen) => {
                    const s = (text ?? '').toString();
                    if (!s) return '';
                    return s.length > maxLen ? (s.substring(0, maxLen) + 'â€¦') : s;
                };

                // ë°ìŠ¤í¬íƒ‘ ë°©ì‹ì— ë§ì¶˜ ìš°ì„ ìˆœìœ„: ê³µë¬¸/ë²•ë ¹/ì§€ì¹¨(ê·¼ê±°) > ì—…ë¬´/ì²´í¬ë¦¬ìŠ¤íŠ¸(ë³´ì¡°) > ì„œì‹(ì œëª©ë§Œ)
                const LAW_DOC_KEYWORDS = ['ë²•ë ¹', 'ì¡°ë¡€', 'ê·œì •', 'ê·œì¹™', 'ê³ ì‹œ', 'í›ˆë ¹', 'ì˜ˆê·œ', 'ì§€ì¹¨', 'ë§¤ë‰´ì–¼', 'ê³µë¬¸', 'ì‹œí–‰', 'í†µë³´', 'ì•ˆë‚´', 'ê³µê³ ', 'ìš”ë ¹', 'ì§€ì‹œ'];
                const FORM_KEYWORDS = ['ì„œì‹', 'ì–‘ì‹', 'í…œí”Œë¦¿', 'template', 'form'];

                const isLikelyFormFile = (name = '', type = '') => {
                    const n = (name || '').toString().toLowerCase();
                    const t = (type || '').toString().toLowerCase();
                    if (FORM_KEYWORDS.some(k => n.includes(k))) return true;
                    if (n.endsWith('.hwp') || n.endsWith('.doc') || n.endsWith('.docx') || n.endsWith('.xls') || n.endsWith('.xlsx') || n.endsWith('.ppt') || n.endsWith('.pptx')) return true;
                    if (t.startsWith('image/')) return true; // ìŠ¤ìº”/ì´ë¯¸ì§€ëŠ” ëª¨ë°”ì¼ì—ì„œ í…ìŠ¤íŠ¸ ë°œì·Œ ë¶ˆê°€
                    return false;
                };

                const isLikelyLawOrOfficial = (name = '', hintText = '') => {
                    const n = (name || '').toString();
                    const s = (hintText || '').toString();
                    const hay = (n + ' ' + s).toLowerCase();
                    if (LAW_DOC_KEYWORDS.some(k => hay.includes(k.toLowerCase()))) return true;
                    if (s.includes('ì œ') && /(\d+)\s*ì¡°/.test(s)) return true;
                    return false;
                };

                let context = '';

                if (useWorkflowContext) {
                    const wf = this.getCurrentWorkflow();
                    if (wf) {
                        // 0) ê·¼ê±° ë¬¸ì„œ(PDF) ìš°ì„ : ê³µë¬¸/ë²•ë ¹/ì§€ì¹¨ ì„±ê²© ë¬¸ì„œë¥¼ ë¨¼ì € ë°œì·Œ
                        try {
                            const docs = await this.getProjectDocs(wf.id);
                            if (docs && docs.length > 0) {
                                const keywords = this.extractKeywords(wf.checklist || []);
                                const scored = docs.map(d => {
                                    const filename = d?.filename || '';
                                    const hint = (d?.summary || '') + ' ' + (d?.content || '').substring(0, 800);
                                    let bonus = 0;
                                    if (isLikelyLawOrOfficial(filename, hint)) bonus += 50;
                                    if (/(\d+)\s*ì¡°/.test(d?.content || '') || /(\d+)\s*ì¡°/.test(d?.summary || '')) bonus += 30;
                                    const base = this.calculateRelevance(d, keywords);
                                    return { doc: d, score: base + bonus };
                                }).sort((a, b) => b.score - a.score);

                                const picked = scored.slice(0, 2).map(x => x.doc);
                                if (picked.length > 0) {
                                    context += `[ê·¼ê±° ë¬¸ì„œ ë°œì·Œ (ê³µë¬¸/ë²•ë ¹/ì§€ì¹¨ ìš°ì„ )]\n`;
                                    for (const doc of picked) {
                                        context += `ğŸ“„ ${doc.filename || 'ë¬¸ì„œ'}\n`;
                                        const extracted = await this.getSmartDocContext(doc, userText, wf.id, apiKey, provider, model);
                                        context += `${truncate(extracted, 2400)}\n\n`;
                                    }
                                    context += `--- ê·¼ê±° ë¬¸ì„œ ë ---\n\n`;
                                }
                            }
                        } catch (e) {
                            // ë¬¸ì„œê°€ ì—†ê±°ë‚˜ ë¡œë“œ ì‹¤íŒ¨ë©´ ë¬´ì‹œ
                        }

                        // 1) ì²¨ë¶€íŒŒì¼(projectFiles): ì„œì‹ì€ ì œëª©ë§Œ, ë²•ë ¹/ê³µë¬¸/ì§€ì¹¨ í…ìŠ¤íŠ¸ë§Œ ë°œì·Œ
                        try {
                            const projectKey = `project-${wf.id}`;
                            const files = await this.dbManager.getProjectFilesByProjectKey(projectKey);
                            if (files && files.length > 0) {
                                // ìµœê·¼ìˆœ ì •ë ¬(ì—…ë¡œë“œì¼ì‹œ ê¸°ì¤€)
                                const sorted = files.slice().sort((a, b) => {
                                    const ta = a?.uploadDate ? new Date(a.uploadDate).getTime() : 0;
                                    const tb = b?.uploadDate ? new Date(b.uploadDate).getTime() : 0;
                                    return tb - ta;
                                });

                                const forms = [];
                                const refs = [];
                                for (const f of sorted) {
                                    const name = f?.fileName || '';
                                    const type = f?.fileType || '';
                                    if (isLikelyFormFile(name, type)) forms.push(f);
                                    else refs.push(f);
                                }

                                const maxList = 12;
                                if (refs.length > 0) {
                                    context += `[ì²¨ë¶€ ìë£Œ(ê³µë¬¸/ë²•ë ¹/ì§€ì¹¨/ì°¸ê³ ) - ì œëª©]\n`;
                                    refs.slice(0, maxList).forEach((f, i) => {
                                        const name = f?.fileName || 'íŒŒì¼';
                                        const type = f?.fileType || '';
                                        const size = typeof f?.fileSize === 'number' ? `${Math.round(f.fileSize / 1024)}KB` : '';
                                        context += `- ${i + 1}) ${name}${type ? ` (${type})` : ''}${size ? ` Â· ${size}` : ''}\n`;
                                    });
                                    if (refs.length > maxList) context += `- â€¦ (ì´ ${refs.length}ê°œ ì¤‘ ${maxList}ê°œë§Œ í‘œì‹œ)\n`;
                                    context += `\n`;
                                }

                                if (forms.length > 0) {
                                    context += `[ì„œì‹/ì–‘ì‹ íŒŒì¼(ì‘ì„±ìš©) - ì œëª©ë§Œ]\n`;
                                    forms.slice(0, maxList).forEach((f, i) => {
                                        const name = f?.fileName || 'ì„œì‹';
                                        const type = f?.fileType || '';
                                        context += `- ${i + 1}) ${name}${type ? ` (${type})` : ''}\n`;
                                    });
                                    if (forms.length > maxList) context += `- â€¦ (ì´ ${forms.length}ê°œ ì¤‘ ${maxList}ê°œë§Œ í‘œì‹œ)\n`;
                                    context += `\n`;
                                }

                                // í…ìŠ¤íŠ¸ ë°œì·ŒëŠ” "ë²•ë ¹/ê³µë¬¸/ì§€ì¹¨"ìœ¼ë¡œ ë³´ì´ëŠ” í…ìŠ¤íŠ¸ íŒŒì¼ë§Œ
                                const textCandidates = refs.filter(f => {
                                    const name = (f?.fileName || '').toLowerCase();
                                    const type = (f?.fileType || '').toLowerCase();
                                    const isText = type.includes('text') || name.endsWith('.txt') || name.endsWith('.md') || name.endsWith('.csv');
                                    const sizeOk = typeof f?.fileSize === 'number' ? f.fileSize <= 250_000 : true;
                                    if (!isText || !sizeOk || !f?.blob) return false;
                                    return isLikelyLawOrOfficial(f.fileName || '', f.fileName || '');
                                }).slice(0, 2);

                                for (const tf of textCandidates) {
                                    try {
                                        const text = await tf.blob.text();
                                        context += `[ì²¨ë¶€ í…ìŠ¤íŠ¸ ë°œì·Œ: ${tf.fileName}]\n${truncate(text, 1600)}\n\n`;
                                    } catch (e) {
                                        // ignore
                                    }
                                }
                            }
                        } catch (e) {
                            // ì²¨ë¶€íŒŒì¼ ì¡°íšŒ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
                        }

                        // 2) ë³´ì¡° ì»¨í…ìŠ¤íŠ¸: ì—…ë¬´/ì²´í¬ë¦¬ìŠ¤íŠ¸(ì„œì‹ì€ ì œëª©ë§Œ) ìš”ì•½ì€ ë’¤ì— ë°°ì¹˜
                        context += `[ì°¸ì¡° ì¤‘ì¸ í˜„ì¬ì—…ë¬´(ìš”ì•½)]\n`;
                        context += `ì œëª©: ${wf.title || ''}\n`;
                        if (wf.content) context += `ë‚´ìš©: ${truncate(wf.content, 900)}\n`;
                        if (wf.deadline) {
                            try {
                                const deadline = new Date(wf.deadline);
                                const today = new Date();
                                const diffTime = deadline - today;
                                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                                context += `ë§ˆê°ì¼: ${wf.deadline} (${diffDays > 0 ? `D-${diffDays}` : diffDays === 0 ? 'D-DAY' : `D+${Math.abs(diffDays)}`})\n`;
                            } catch (e) {
                                context += `ë§ˆê°ì¼: ${wf.deadline}\n`;
                            }
                        }
                        context += `\n`;

                        if (wf.checklist && Array.isArray(wf.checklist) && wf.checklist.length > 0) {
                            const progress = this.calculateProgress(wf);
                            const total = wf.checklist.length;
                            const completedCount = wf.checklist.filter(it => this.normalizeCompleted(it) || it.skipped === true).length;
                            context += `[ì²´í¬ë¦¬ìŠ¤íŠ¸ - ì§„í–‰ë¥ : ${progress}% (${completedCount}/${total})]\n`;

                            const maxItems = 60;
                            const itemsToShow = wf.checklist.slice(0, maxItems);
                            itemsToShow.forEach((item, idx) => {
                                const num = idx + 1;
                                const isDone = this.normalizeCompleted(item);
                                const isSkipped = item && item.skipped === true;
                                const status = isSkipped ? 'ğŸš«(ê±´ë„ˆëœ€)' : (isDone ? 'âœ…' : 'â¬œ');

                                let line = `${num}. ${truncate(item?.text || '', 120)} ${status}`;

                                if (item?.formats && Array.isArray(item.formats) && item.formats.length > 0) {
                                    const formatNames = item.formats.map(f => {
                                        if (typeof f === 'string') return f;
                                        if (f && typeof f === 'object' && f.name) return f.name;
                                        return String(f);
                                    }).filter(Boolean).slice(0, 6).join(', ');
                                    if (formatNames) line += ` | ğŸ“‹ì„œì‹(ì œëª©): ${truncate(formatNames, 120)}`;
                                }

                                if (item?.result?.summary) {
                                    line += ` | ğŸ¤–ìš”ì•½: ${truncate(item.result.summary, 140)}`;
                                }
                                if (item?.tip?.content) {
                                    line += ` | ğŸ’¡íŒ: ${truncate(item.tip.content, 120)}`;
                                }

                                context += line + `\n`;
                            });

                            if (total > maxItems) context += `â€¦ (ì´ ${total}ê°œ ì¤‘ ${maxItems}ê°œë§Œ í‘œì‹œ)\n`;
                            context += `\n`;
                        }
                    }
                }

                return [
                    `ë‹¹ì‹ ì€ í–‰ì •/ì—…ë¬´ ì§„í–‰ì„ ë•ëŠ” 'AI ì—…ë¬´íŒŒíŠ¸ë„ˆ'ì…ë‹ˆë‹¤.`,
                    `ê°€ëŠ¥í•˜ë©´ ì•„ë˜ [ê·¼ê±° ë¬¸ì„œ ë°œì·Œ]ì™€ [ì²¨ë¶€ ìë£Œ]ì—ì„œ í™•ì¸ë˜ëŠ” ë‚´ìš©(ê³µë¬¸/ë²•ë ¹/ì§€ì¹¨)ì„ ìµœìš°ì„  ê·¼ê±°ë¡œ ë‹µë³€í•˜ì„¸ìš”.`,
                    `ì„œì‹/ì–‘ì‹ íŒŒì¼ì€ ì‘ì„±ìš©ì´ë¯€ë¡œ "ì œëª©(ì´ë¦„)"ë§Œ ì°¸ê³ í•˜ê³ , ë‚´ìš©ì€ ì¶”ì •í•˜ê±°ë‚˜ ì¸ìš©í•˜ì§€ ë§ˆì„¸ìš”.`,
                    `ë‹µë³€ì€ í•œêµ­ì–´ë¡œ, í•µì‹¬ë¶€í„° ì§§ê²Œ ì‹œì‘í•˜ê³  í•„ìš” ì‹œ ë‹¨ê³„ë³„ë¡œ ì •ë¦¬í•´ ì£¼ì„¸ìš”.`,
                    `ì‚¬ìš©ìê°€ ë‹¤ìŒ í–‰ë™ì„ ë°”ë¡œ í•  ìˆ˜ ìˆê²Œ ì²´í¬ë¦¬ìŠ¤íŠ¸/ì˜ˆì‹œ ë¬¸êµ¬/ì£¼ì˜ì‚¬í•­ì„ í¬í•¨í•´ ì£¼ì„¸ìš”.`,
                    `ë°˜ë“œì‹œ ì•„ë˜ í˜•ì‹ì„ í¬í•¨í•˜ì„¸ìš”:\n- ê·¼ê±°: (ë¬¸ì„œëª…/ì¡°í•­/ë°œì·Œ ê·¼ê±°ë¥¼ bulletë¡œ)\n- í™•ì‹ ë„: ë†’ìŒ/ë³´í†µ/ë‚®ìŒ (ê·¼ê±° ìœ ë¬´ë¡œ íŒë‹¨)\n- í™•ì¸ í•„ìš”: ë¬¸ì„œì—ì„œ í™•ì¸ë˜ì§€ ì•Šì€ ë¶€ë¶„ì€ ì§ˆë¬¸ìœ¼ë¡œ ë˜ë¬»ê¸°`,
                    ``,
                    context ? context.trim() : '',
                    `[ì‚¬ìš©ì ì§ˆë¬¸]\n${userText}`,
                    ``,
                    `(ì°¸ê³ ) í˜„ì¬ ì„¤ì •: provider=${provider}, model=${model}`
                ].filter(Boolean).join('\n');
            }

            toggleChecklistItem(workflowId, itemIndex) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow || !workflow.checklist) return;

                const item = workflow.checklist[itemIndex];
                if (!item) return;

                item.completed = !this.normalizeCompleted(item);
                if (item.completed) {
                    item.completedAt = new Date().toISOString();
                } else {
                    item.completedAt = null;
                }

                this.saveWorkflow(workflow);
                this.displayWorkflows();
                
                // ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸
                if (this.currentWorkflowId === workflowId) {
                    this.showChecklist(workflowId);
                }
            }

            async showAIGuide(workflowId, itemIndex) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow || !workflow.checklist) return;

                const item = workflow.checklist[itemIndex];
                if (!item) return;

                this.currentWorkflowId = workflowId;
                this.currentItemIndex = itemIndex;

                const provider = this.allData.provider;
                let apiKey;
                if (provider === 'gemini') {
                    apiKey = this.allData.geminiApiKey;
                } else if (provider === 'chatgpt') {
                    apiKey = this.allData.chatgptApiKey;
                } else if (provider === 'claude') {
                    apiKey = this.allData.claudeApiKey;
                }

                if (!apiKey) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”');
                    return;
                }

                this.showToast('info', 'â³', 'AI ê¸¸ì¡ì´ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘...');

                try {
                    const prompt = await this.buildAIGuidePrompt(workflow, item, itemIndex);
                    const helpText = await this.callAI(prompt);
                    const content = document.getElementById('aiGuideContent');
                    if (content) {
                        const html = this.renderMarkdownToHtml(helpText);
                        content.innerHTML = `<div class="md">${html}</div>`;
                    }
                    this.openModal('aiGuideModal');
                    this.showToast('success', 'âœ…', 'AI ê¸¸ì¡ì´ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤');
                } catch (error) {
                    this.showToast('error', 'âŒ', 'AI í˜¸ì¶œ ì‹¤íŒ¨: ' + error.message);
                }
            }

            async buildAIGuidePrompt(workflow, item, itemIndex) {
                // í˜„ì¬ í•­ëª©ì˜ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const latestWorkflow = this.allData.workflows.find(w => w.id === workflow.id);
                let currentItem = item;
                if (latestWorkflow && latestWorkflow.checklist && latestWorkflow.checklist[itemIndex]) {
                    currentItem = latestWorkflow.checklist[itemIndex];
                }

                // ì—…ë¬´ ì •ë³´
                let prompt = `[ì—…ë¬´ ì •ë³´]\nì œëª©: ${workflow.title}\n`;
                if (workflow.content) {
                    prompt += `ë‚´ìš©: ${workflow.content}\n`;
                }

                // í˜„ì¬ í•­ëª© ì •ë³´
                prompt += `\n[í˜„ì¬ í•­ëª© ìƒì„¸ ì •ë³´]\n`;
                prompt += `í•­ëª©: ${currentItem.text}\n`;

                // ì²¨ë¶€ì„œì‹ í™•ì¸
                let hasFormats = false;
                let formatNames = '';
                if (currentItem.formats && Array.isArray(currentItem.formats) && currentItem.formats.length > 0) {
                    const formatList = currentItem.formats.map(f => {
                        if (typeof f === 'string') return f;
                        if (f && typeof f === 'object' && f.name) return f.name;
                        return String(f);
                    }).filter(name => name && name.trim());
                    
                    if (formatList.length > 0) {
                        hasFormats = true;
                        formatNames = formatList.join(', ');
                        prompt += `ğŸ“‹ ì²¨ë¶€ì„œì‹: ${formatNames}\n`;
                    }
                }
                if (!hasFormats) {
                    prompt += `ğŸ“‹ ì²¨ë¶€ì„œì‹: ì—†ìŒ\n`;
                }

                // ì €ì¥ëœ ì—…ë¬´íŒ
                if (currentItem.tip?.content && currentItem.tip.content.trim()) {
                    prompt += `ğŸ’¡ ì €ì¥ëœ ì—…ë¬´íŒ: ${currentItem.tip.content}\n`;
                }

                // checklistDetails ì •ë³´
                const detailKey = `${workflow.id}-${itemIndex}`;
                const details = this.checklistDetails[detailKey];
                if (details) {
                    if (details.tip && details.tip.trim()) {
                        prompt += `ğŸ’¡ ìƒì„¸ íŒ: ${details.tip}\n`;
                    }
                    if (details.details && details.details.trim()) {
                        prompt += `ğŸ“ ìƒì„¸ ì •ë³´: ${details.details}\n`;
                    }
                    if (details.law && details.law.trim()) {
                        prompt += `âš–ï¸ ë²•ë ¹ ì •ë³´: ${details.law}\n`;
                    }
                    if (details.memo && details.memo.trim()) {
                        prompt += `ğŸ“Œ ë©”ëª¨: ${details.memo}\n`;
                    }
                }
                prompt += '\n';

                // ì „ì²´ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì •ë³´
                let checklistContext = '';
                if (workflow.checklist && workflow.checklist.length > 0) {
                    checklistContext = '[ì „ì²´ ì²´í¬ë¦¬ìŠ¤íŠ¸]\n';
                    workflow.checklist.forEach((it, idx) => {
                        const isCurrent = idx === itemIndex;
                        const prefix = isCurrent ? 'ğŸ‘‰ í˜„ì¬: ' : `${idx + 1}. `;
                        let status = this.normalizeCompleted(it) ? ' âœ…' : ' â¬œ';
                        if (it.skipped) status = ' ğŸš« (ê±´ë„ˆëœ€)';
                        checklistContext += `${prefix}${it.text}${status}\n`;
                    });
                }

                // ì´ì „ ì™„ë£Œ í•­ëª©ì˜ ê²½í—˜/ê²°ê³¼
                let completedExperience = '';
                const completedItems = workflow.checklist.filter((it, idx) => 
                    idx < itemIndex && this.normalizeCompleted(it)
                );
                
                if (completedItems.length > 0) {
                    completedExperience = '[ì´ì „ ì™„ë£Œ í•­ëª©ì˜ ê²½í—˜/ê²°ê³¼]\n';
                    completedItems.slice(-3).forEach((it, idx) => {
                        completedExperience += `${idx + 1}. ${it.text}\n`;
                        if (it.result?.summary) {
                            completedExperience += `   ğŸ¤– ê²°ê³¼: ${it.result.summary}\n`;
                        }
                        if (it.tip?.content) {
                            completedExperience += `   ğŸ’¡ íŒ: ${it.tip.content}\n`;
                        }
                    });
                    completedExperience += '\n';
                }

                // ì°¸ì¡° ë¬¸ì„œ (PDF ë¬¸ì„œ)
                let docContext = '';
                try {
                    const docs = await this.getProjectDocs(workflow.id);
                    if (docs && docs.length > 0) {
                        const relevantDocs = this.selectRelevantDocs(docs, workflow.checklist, 1);
                        const selectedDoc = relevantDocs.length > 0 ? relevantDocs[0] : docs[0];
                        
                        if (selectedDoc) {
                            const provider = this.allData.provider;
                            const model = this.allData.selectedModel[provider];
                            let apiKey;
                            if (provider === 'gemini') {
                                apiKey = this.allData.geminiApiKey;
                            } else if (provider === 'chatgpt') {
                                apiKey = this.allData.chatgptApiKey;
                            } else if (provider === 'claude') {
                                apiKey = this.allData.claudeApiKey;
                            }
                            
                            if (apiKey) {
                                try {
                                    const questionText = currentItem.text || '';
                                    docContext = await this.getSmartDocContext(selectedDoc, questionText, workflow.id, apiKey, provider, model);
                                } catch (error) {
                                    console.error('ë¬¸ì„œ ìš”ì•½ ì˜¤ë¥˜:', error);
                                    docContext = selectedDoc.content ? selectedDoc.content.substring(0, 2000) : '';
                                }
                            } else if (selectedDoc.content) {
                                docContext = selectedDoc.content.substring(0, 2000);
                            }
                        }
                    }
                } catch (error) {
                    console.error('ë¬¸ì„œ ë¡œë“œ ì˜¤ë¥˜:', error);
                }

                // ë§ˆê°ì¼ ì •ë³´
                let deadlineInfo = '';
                if (workflow.deadline) {
                    const deadline = new Date(workflow.deadline);
                    const today = new Date();
                    const diffTime = deadline - today;
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    
                    if (diffDays > 0) {
                        deadlineInfo = `\n[ë§ˆê°ì¼ ì •ë³´]\n- ë§ˆê°ì¼: ${workflow.deadline}\n- ë‚¨ì€ ì¼ìˆ˜: ${diffDays}ì¼\n`;
                    } else if (diffDays === 0) {
                        deadlineInfo = `\n[ë§ˆê°ì¼ ì •ë³´]\n- ë§ˆê°ì¼: ${workflow.deadline}\n- âš ï¸ ì˜¤ëŠ˜ ë§ˆê°ì…ë‹ˆë‹¤!\n`;
                    } else {
                        deadlineInfo = `\n[ë§ˆê°ì¼ ì •ë³´]\n- ë§ˆê°ì¼: ${workflow.deadline}\n- âš ï¸ ë§ˆê°ì¼ì´ ì§€ë‚¬ìŠµë‹ˆë‹¤ (${Math.abs(diffDays)}ì¼ ê²½ê³¼)\n`;
                    }
                }

                // ì§„í–‰ë¥  ê³„ì‚°
                const progress = this.calculateProgress(workflow);
                const completedCount = workflow.checklist.filter(it => this.normalizeCompleted(it)).length;
                const isCurrentCompleted = this.normalizeCompleted(currentItem);

                // ìµœì¢… í”„ë¡¬í”„íŠ¸ êµ¬ì„±
                const finalPrompt = `
[í˜„ì¬ ìƒí™©]
- ì—…ë¬´: ${workflow.title}
- ì§„í–‰ë¥ : ${progress}% (${completedCount}/${workflow.checklist.length} ì™„ë£Œ)
- í˜„ì¬ í•­ëª©: ${currentItem.text} ${isCurrentCompleted ? 'âœ…' : 'â¬œ'}

${completedExperience}

${prompt}

${checklistContext}

[ì°¸ì¡° ë¬¸ì„œ]
${docContext}${deadlineInfo}

ã€ì¤‘ìš” ì§€ì‹œì‚¬í•­ã€‘
1. í˜„ì¬ í•­ëª©ì— ì´ë¯¸ ì €ì¥ëœ ì •ë³´(ì—…ë¬´íŒ, ì²¨ë¶€ì„œì‹, ìƒì„¸ ì •ë³´)ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  í™œìš©í•˜ì„¸ìš”.
2. ì €ì¥ëœ ì •ë³´ê°€ ì—†ì„ ë•Œë§Œ AIê°€ ìƒˆë¡œ ìƒì„±í•˜ì„¸ìš”.
3. ì´ì „ ì™„ë£Œ í•­ëª©ì˜ ê²½í—˜ê³¼ ê²°ê³¼ë¥¼ ì°¸ê³ í•˜ì—¬ ë” ë‚˜ì€ ê°€ì´ë“œë¥¼ ì œê³µí•˜ì„¸ìš”.
4. ë§ˆê°ì¼ì´ ê°€ê¹Œìš°ë©´ ì‹œê°„ ê´€ë¦¬ì— ëŒ€í•œ ì¡°ì–¸ì„ í¬í•¨í•˜ì„¸ìš”.
5. ã€ë§¤ìš° ì¤‘ìš” - ì„œì‹ ì •ë³´ í™œìš©ã€‘ìœ„ì˜ "[í˜„ì¬ í•­ëª© ìƒì„¸ ì •ë³´]"ì— "ğŸ“‹ ì²¨ë¶€ì„œì‹" ì •ë³´ê°€ ìˆìœ¼ë©´, ë°˜ë“œì‹œ ê·¸ íŒŒì¼ëª…ë“¤ì„ "2ï¸âƒ£ í•„ìš”í•œ ì„œì‹Â·ì˜ˆì‹œ ë¬¸ì„œ" ì„¹ì…˜ì—ì„œ ì •í™•íˆ ì–¸ê¸‰í•˜ê³  ì•ˆë‚´í•˜ì„¸ìš”.
6. í˜„ì¬ í•­ëª©ì— ì²¨ë¶€ì„œì‹ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ "ë³„ë„ ì„œì‹ ì—†ì´ ì§„í–‰í•´ë„ ë©ë‹ˆë‹¤" ë˜ëŠ” "ê¸°ê´€ì—ì„œ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì¼ë°˜ ì–‘ì‹ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤" ì •ë„ë¡œë§Œ ì•ˆë‚´í•˜ì„¸ìš”.
7. ã€ë§¤ìš° ì¤‘ìš”ã€‘ë‹µë³€ì€ í•µì‹¬ë§Œ ê°„ê²°í•˜ê²Œ ì‘ì„±í•˜ì„¸ìš”. ê° ì„¹ì…˜ì€ 2-3ì¤„ë¡œ ìš”ì•½í•˜ê³ , ë¶ˆí•„ìš”í•œ ì„¤ëª…ì´ë‚˜ ë°˜ë³µì€ ìƒëµí•˜ì„¸ìš”.

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”:

1ï¸âƒ£ í˜„ì¬ í•  ì¼
- êµ¬ì²´ì ì¸ ì‘ì—… ë‚´ìš©
- í˜„ì¬ í•­ëª©: "${currentItem.text}"ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ ë‹¨ê³„ë³„ ê°€ì´ë“œ

2ï¸âƒ£ í•„ìš”í•œ ì„œì‹Â·ì˜ˆì‹œ ë¬¸ì„œ
${hasFormats && formatNames ? 
    `ã€ë°˜ë“œì‹œ ì´ ë‚´ìš©ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì„¸ìš”ã€‘
- ì²¨ë¶€ëœ ì„œì‹/ì˜ˆì‹œ ë¬¸ì„œ: ${formatNames}
- ì´ íŒŒì¼ë“¤ì€ "ì„œì‹ ì¶”ê°€í•˜ê¸°"ì—ì„œ ì´ë¯¸ ì—…ë¡œë“œë˜ì–´ ìˆìŠµë‹ˆë‹¤
- ì„œì‹ íŒŒì¼ì€ ë‚´ë ¤ë°›ì•„ ê·¸ëŒ€ë¡œ ì‘ì„±Â·ì œì¶œí•˜ì„¸ìš”
- ì˜ˆì‹œ ê³µë¬¸ íŒŒì¼ì€ í˜•ì‹ê³¼ í‘œí˜„ì„ ì°¸ê³ í•˜ì—¬ ìš°ë¦¬ ê¸°ê´€ ì–‘ì‹ì— ë§ê²Œ ìƒˆ ê³µë¬¸ì„ ì‘ì„±í•˜ì„¸ìš”` : 
    '- ìœ„ì˜ "[í˜„ì¬ í•­ëª© ìƒì„¸ ì •ë³´]"ë¥¼ í™•ì¸í•œ ê²°ê³¼, ì´ í•­ëª©ì—ëŠ” ë³„ë„ë¡œ ì²¨ë¶€ëœ ì„œì‹ì´ë‚˜ ì˜ˆì‹œ ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤. ë³„ë„ ì„œì‹ ì—†ì´ ì§„í–‰í•˜ê±°ë‚˜, ê¸°ê´€ì—ì„œ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ê¸°ë³¸ ì–‘ì‹ê³¼ ë¶€ì„œ ì§€ì¹¨ì— ë”°ë¼ ì§„í–‰í•˜ë¼ê³  ì•ˆë‚´í•˜ì„¸ìš”.'}

3ï¸âƒ£ ì£¼ì˜ì‚¬í•­
- ì €ì¥ëœ ì£¼ì˜ì‚¬í•­ë“¤ì„ ëª¨ë‘ ë‚˜ì—´í•˜ì„¸ìš”
${docContext && docContext.trim() ? '- [ì°¸ì¡° ë¬¸ì„œ]ì—ì„œ í˜„ì¬ í•­ëª©ê³¼ ê´€ë ¨ëœ ì£¼ì˜ì‚¬í•­ì„ ì¶”ì¶œí•˜ì—¬ ì¶”ê°€ë¡œ í¬í•¨í•˜ì„¸ìš”' : '- [ì°¸ì¡° ë¬¸ì„œ]ê°€ ì—†ìœ¼ë¯€ë¡œ ì €ì¥ëœ ì£¼ì˜ì‚¬í•­ë§Œ í‘œì‹œí•˜ê³  ì„ì˜ë¡œ ì¶”ê°€ ì£¼ì˜ì‚¬í•­ì„ ìƒì„±í•˜ì§€ ë§ˆì„¸ìš”'}

4ï¸âƒ£ ì˜ˆìƒ ì†Œìš”ì‹œê°„
- ì‹œê°„ ì˜ˆìƒ
${deadlineInfo ? `- ë§ˆê°ì¼ ê³ ë ¤: ${deadlineInfo.includes('ì˜¤ëŠ˜ ë§ˆê°') ? 'ì˜¤ëŠ˜ ë§ˆê°ì´ë¯€ë¡œ ì‹ ì†íˆ ì§„í–‰í•˜ì„¸ìš”' : deadlineInfo.includes('ì§€ë‚¬ìŠµë‹ˆë‹¤') ? 'ë§ˆê°ì¼ì´ ì§€ë‚¬ìœ¼ë¯€ë¡œ ì¦‰ì‹œ ì§„í–‰í•˜ì„¸ìš”' : 'ë§ˆê°ì¼ê¹Œì§€ ì‹œê°„ì„ ê³ ë ¤í•˜ì—¬ ê³„íší•˜ì„¸ìš”'}` : ''}
                `.trim();

                return finalPrompt;
            }

            async callAI(prompt) {
                const provider = this.allData.provider;
                const model = this.allData.selectedModel[provider];
                let apiKey;
                
                if (provider === 'gemini') {
                    apiKey = this.allData.geminiApiKey;
                    return await this.callGeminiAPI(apiKey, model, prompt);
                } else if (provider === 'chatgpt') {
                    apiKey = this.allData.chatgptApiKey;
                    return await this.callChatGPTAPI(apiKey, model, prompt);
                } else if (provider === 'claude') {
                    apiKey = this.allData.claudeApiKey;
                    return await this.callClaudeAPI(apiKey, model, prompt);
                }
            }

            async callGeminiAPI(apiKey, model, prompt) {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: prompt }]
                        }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ì˜¤ë¥˜: ${response.status}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }

            async callChatGPTAPI(apiKey, model, prompt) {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ì˜¤ë¥˜: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async callClaudeAPI(apiKey, model, prompt) {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: model,
                        max_tokens: 4096,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ì˜¤ë¥˜: ${response.status}`);
                }

                const data = await response.json();
                return data.content[0].text;
            }

            async saveWorkflow(workflow) {
                try {
                    await this.dbManager.saveProject(workflow);
                } catch (error) {
                    console.error('ì—…ë¬´ ì €ì¥ ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ì €ì¥ ì‹¤íŒ¨: ' + error.message);
                }
            }

            // ì—…ë¬´ ê°€ì ¸ì˜¤ê¸°
            importProjectPackage() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const packageData = JSON.parse(text);

                        if (packageData.type !== 'project' && packageData.type !== 'yearly-backup') {
                            throw new Error('ì˜¬ë°”ë¥¸ ì—…ë¬´ íŒ¨í‚¤ì§€ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.');
                        }

                        if (!packageData.projects || !Array.isArray(packageData.projects) || packageData.projects.length === 0) {
                            throw new Error('ê°€ì ¸ì˜¬ ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        }

                        this.tempImportData = packageData;
                        this.showImportModeModal();
                    } catch (error) {
                        console.error('íŒŒì¼ ì½ê¸° ì˜¤ë¥˜:', error);
                        this.showToast('error', 'âŒ', 'íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ' + error.message);
                    }
                };
                input.click();
            }

            showImportModeModal() {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                const projectCount = this.tempImportData.projects.length;
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ğŸ“¦ ì—…ë¬´ ê°€ì ¸ì˜¤ê¸°</div>
                            <button class="close-btn" onclick="this.closest('.modal').remove()">Ã—</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 20px; color: var(--text-gray); font-size: 0.9rem;">
                                ê°€ì ¸ì˜¬ ì—…ë¬´: <strong>${projectCount}ê°œ</strong>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 12px;">
                                <button class="btn btn-primary" onclick="app.processImport('asIs')" style="padding: 16px; text-align: center; font-weight: 600;">
                                    ê·¸ëŒ€ë¡œ ê°€ì ¸ì˜¤ê¸°
                                </button>
                                <button class="btn btn-secondary" onclick="app.processImport('new')" style="padding: 16px; text-align: center; font-weight: 600;">
                                    ìƒˆ ì—…ë¬´ë¡œ ì‹œì‘
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            async processImport(mode) {
                const modal = document.querySelector('.modal.show');
                if (modal) modal.remove();

                if (!this.tempImportData) {
                    this.showToast('error', 'âŒ', 'ê°€ì ¸ì˜¬ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                const packageData = this.tempImportData;
                this.tempImportData = null;

                this.showToast('info', 'â³', 'íŒ¨í‚¤ì§€ ê°€ì ¸ì˜¤ëŠ” ì¤‘...');

                try {
                    const todayDate = new Date().toISOString().slice(0, 10);
                    const todayDateKR = new Date().toLocaleDateString('ko-KR');
                    let importedCount = 0;

                    for (const project of packageData.projects) {
                        if (!project || !project.id) continue;

                        const oldId = project.id;
                        project.id = Date.now() + Math.random();
                        project.importedAt = new Date().toISOString();
                        project.originalId = oldId;

                        if (mode === 'new') {
                            project.createdAt = todayDate;
                            project.date = todayDateKR;
                            if (project.checklist && Array.isArray(project.checklist)) {
                                project.checklist.forEach(item => {
                                    item.completed = false;
                                    item.completedAt = null;
                                });
                            }
                        }

                        await this.dbManager.saveProject(project);
                        this.allData.workflows.push(project);
                        this.lastImportedWorkflowIds.push(project.id);
                        importedCount++;

                        // ì²´í¬ë¦¬ìŠ¤íŠ¸ ì„¸ë¶€ ì •ë³´ ë³µì›
                        const projectKey = `project-${project.id}`;
                        if (packageData.files) {
                            for (const key in packageData.files) {
                                if (key.includes(`project-${oldId}-`)) {
                                    const fileInfo = packageData.files[key];
                                    if (fileInfo && fileInfo.data) {
                                        const blob = await this.base64ToBlob(fileInfo.data, fileInfo.type);
                                        const fileData = {
                                            projectKey: projectKey,
                                            fileName: fileInfo.name,
                                            fileType: fileInfo.type,
                                            fileSize: blob.size,
                                            blob: blob,
                                            uploadDate: new Date().toISOString()
                                        };
                                        await this.dbManager.saveFile('projectFiles', fileData);
                                    }
                                }
                            }
                        }
                    }

                    this.displayWorkflows();
                    
                    // 3ì´ˆ í›„ NEW ë±ƒì§€ ì œê±°
                    setTimeout(() => {
                        this.lastImportedWorkflowIds = [];
                        this.displayWorkflows();
                    }, 3000);
                    
                    this.showToast('success', 'âœ…', `ì—…ë¬´ ${importedCount}ê°œ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ`);
                } catch (error) {
                    console.error('ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message);
                }
            }

            base64ToBlob(base64, mimeType) {
                const byteCharacters = atob(base64.split(',')[1] || base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            }

            // API ì„¤ì •
            selectProvider(provider) {
                this.allData.provider = provider;
                document.getElementById('geminiSettings').style.display = provider === 'gemini' ? 'block' : 'none';
                document.getElementById('chatgptSettings').style.display = provider === 'chatgpt' ? 'block' : 'none';
                document.getElementById('claudeSettings').style.display = provider === 'claude' ? 'block' : 'none';
            }

            selectModel(provider, model) {
                this.allData.selectedModel[provider] = model;
            }

            resetApiKeyInput(provider) {
                const input = document.getElementById(provider + 'ApiKeyInput');
                if (input) {
                    input.value = '';
                    input.type = 'text';
                    input.focus();
                }
            }

            async saveApiKey() {
                const provider = this.allData.provider;
                const input = document.getElementById(provider + 'ApiKeyInput');
                if (!input) return;

                const apiKey = input.value.trim();
                if (!apiKey || apiKey.includes('âœ…')) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”');
                    return;
                }

                if (provider === 'gemini') {
                    this.allData.geminiApiKey = apiKey;
                } else if (provider === 'chatgpt') {
                    this.allData.chatgptApiKey = apiKey;
                } else if (provider === 'claude') {
                    this.allData.claudeApiKey = apiKey;
                }

                // API í‚¤ ì €ì¥ (AES-GCM ì•”í˜¸í™”)
                const keys = {
                    gemini: await this.encryptApiKey(this.allData.geminiApiKey),
                    chatgpt: await this.encryptApiKey(this.allData.chatgptApiKey),
                    claude: await this.encryptApiKey(this.allData.claudeApiKey)
                };
                localStorage.setItem(this.API_KEY_STORAGE, JSON.stringify(keys));

                // ì„¤ì • ì €ì¥
                const settings = {
                    provider: this.allData.provider,
                    selectedModel: this.allData.selectedModel
                };
                localStorage.setItem('appSettings_v5.2', JSON.stringify(settings));

                input.value = 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                input.type = 'password';
                
                // ëª¨ë‹¬ ë‹«ê¸°
                this.closeModal('settingsModal');
                this.showToast('success', 'âœ…', 'API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
            }

            async testApiConnection() {
                const provider = this.allData.provider;
                let apiKey;
                if (provider === 'gemini') {
                    apiKey = this.allData.geminiApiKey;
                } else if (provider === 'chatgpt') {
                    apiKey = this.allData.chatgptApiKey;
                } else if (provider === 'claude') {
                    apiKey = this.allData.claudeApiKey;
                }

                if (!apiKey) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”');
                    return;
                }

                this.showToast('info', 'â³', 'API ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘...');

                try {
                    await this.callAI('í…ŒìŠ¤íŠ¸');
                    this.showToast('success', 'âœ…', 'API ì—°ê²° ì„±ê³µ');
                } catch (error) {
                    this.showToast('error', 'âŒ', 'API ì—°ê²° ì‹¤íŒ¨: ' + error.message);
                }
            }

            // ëª¨ë‹¬ ê´€ë¦¬
            openModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.add('show');
                    document.body.style.overflow = 'hidden';
                }
            }

            closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('show');
                    // ë‹¤ë¥¸ ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ìŠ¤í¬ë¡¤ ì ê¸ˆ ìœ ì§€
                    const hasAnyOpenModal = document.querySelector('.modal.show');
                    document.body.style.overflow = hasAnyOpenModal ? 'hidden' : '';
                }
            }

            // ìœ í‹¸ë¦¬í‹°
            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // ë¶„ê¸° ì˜µì…˜ ì²˜ë¦¬ (ê±´ë„ˆë›°ê¸°)
            handleBranchOption(workflowId, index, action, label) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow || !workflow.checklist) {
                    return;
                }

                const currentItem = workflow.checklist[index];
                if (!currentItem) {
                    return;
                }
                
                // ì´ë¯¸ ë¶„ê¸° ì²˜ë¦¬ê°€ ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
                if (currentItem.branchActionTaken) {
                    this.showToast('error', 'âš ï¸', 'ì´ë¯¸ ë¶„ê¸° ì²˜ë¦¬ê°€ ì™„ë£Œëœ í•­ëª©ì…ë‹ˆë‹¤. ì‹¤í–‰ì·¨ì†Œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.');
                    return;
                }
                
                // ê±´ë„ˆë›´ í•­ëª©ì€ ë¶„ê¸° ì²˜ë¦¬ ë¶ˆê°€
                if (currentItem.skipped === true) {
                    this.showToast('error', 'ğŸš«', 'ê±´ë„ˆë›´ í•­ëª©ì€ ë¶„ê¸° ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ì™„ë£Œëœ í•­ëª©ì€ ë¶„ê¸° ì²˜ë¦¬ ë¶ˆê°€ (ì´ë¯¸ ì™„ë£Œë˜ì—ˆìœ¼ë¯€ë¡œ)
                // ë‹¨, ì‹¤í–‰ì·¨ì†Œ ì§í›„ì—ëŠ” completedê°€ falseì´ë¯€ë¡œ ì´ ì²´í¬ëŠ” ê±´ë„ˆëœ€
                // (ë¶„ê¸° ë²„íŠ¼ì´ í‘œì‹œë˜ëŠ” ì¡°ê±´ì—ì„œ ì´ë¯¸ ì²´í¬ë¨)
                
                // 1. í˜„ì¬ í•­ëª© ì™„ë£Œ ì²˜ë¦¬ (boolean íƒ€ì… ë³´ì¥)
                currentItem.completed = true;
                currentItem.completedAt = new Date().toLocaleString('ko-KR');
                currentItem.result = currentItem.result || {};
                currentItem.result.text = `[ìë™ ì…ë ¥] ${label} ì„ íƒìœ¼ë¡œ ì¸í•œ ë¶„ê¸° ì²˜ë¦¬ë¨`;
                
                // ë¶„ê¸° ì‹¤í–‰ ì´ë ¥ ì €ì¥
                currentItem.branchActionTaken = {
                    action: action,
                    label: label,
                    timestamp: new Date().toISOString()
                };
                
                // 2. ì•¡ì…˜ íŒŒì‹± ë° ì²˜ë¦¬ (ì˜ˆ: "skip:6-14, 16, 18-20")
                if (action.startsWith('skip:')) {
                    const rangesStr = action.split(':')[1];
                    const parts = rangesStr.split(',').map(s => s.trim());
                    
                    parts.forEach(part => {
                        let start, end;
                        
                        if (part.includes('-')) {
                            [start, end] = part.split('-').map(n => parseInt(n));
                        } else {
                            start = parseInt(part);
                            end = start;
                        }
                        
                        if (start && end) {
                            if (start > end) [start, end] = [end, start];
                            
                            // 1-based indexë¥¼ 0-basedë¡œ ë³€í™˜í•˜ê³  end í¬í•¨
                            for (let i = start - 1; i <= end - 1; i++) {
                                if (i >= 0 && i < workflow.checklist.length && workflow.checklist[i]) {
                                    workflow.checklist[i].skipped = true;
                                    workflow.checklist[i].skipReason = `${label} (${currentItem.text})`;
                                    workflow.checklist[i].completed = false;
                                }
                            }
                        }
                    });
                }

                this.saveWorkflow(workflow);
                this.showToast('success', 'ğŸ”€', `${label} ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                
                // UI ì—…ë°ì´íŠ¸
                if (this.currentWorkflowId === workflowId) {
                    // ì•½ê°„ì˜ ì§€ì—°ì„ ë‘ê³  ì—…ë°ì´íŠ¸í•˜ì—¬ ìƒíƒœê°€ í™•ì‹¤íˆ ë°˜ì˜ë˜ë„ë¡
                    setTimeout(() => {
                        this.showChecklist(workflowId);
                    }, 100);
                } else {
                    this.displayWorkflows();
                }
            }

            // ë¶„ê¸° ì‹¤í–‰ ì·¨ì†Œ (ë˜ëŒë¦¬ê¸°)
            undoBranchOption(workflowId, index) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow || !workflow.checklist) return;

                const currentItem = workflow.checklist[index];
                if (!currentItem.branchActionTaken) return;

                if (!confirm('ë¶„ê¸° ì²˜ë¦¬ë¥¼ ì·¨ì†Œí•˜ê³  ì›ë˜ëŒ€ë¡œ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?\n(ê±´ë„ˆë›°ì—ˆë˜ í•­ëª©ë“¤ì´ ë‹¤ì‹œ í™œì„±í™”ë©ë‹ˆë‹¤)')) return;

                const { action, label } = currentItem.branchActionTaken;
                
                // 1. skipëœ í•­ëª©ë“¤ ë³µêµ¬
                if (action && action.startsWith('skip:')) {
                    const rangesStr = action.split(':')[1];
                    const parts = rangesStr.split(',').map(s => s.trim());
                    
                    parts.forEach(part => {
                        let start, end;
                        if (part.includes('-')) {
                            [start, end] = part.split('-').map(n => parseInt(n));
                        } else {
                            start = parseInt(part);
                            end = start;
                        }
                        
                        if (start && end) {
                            if (start > end) [start, end] = [end, start];
                            
                            // 1-based indexë¥¼ 0-basedë¡œ ë³€í™˜í•˜ê³  end í¬í•¨
                            for (let i = start - 1; i <= end - 1; i++) {
                                if (i >= 0 && i < workflow.checklist.length && workflow.checklist[i]) {
                                    if (workflow.checklist[i].skipReason && workflow.checklist[i].skipReason.startsWith(label)) {
                                        delete workflow.checklist[i].skipped;
                                        delete workflow.checklist[i].skipReason;
                                    }
                                }
                            }
                        }
                    });
                }

                // 2. í˜„ì¬ í•­ëª© ìƒíƒœ ë³µêµ¬
                // result ê°ì²´ì—ì„œ [ìë™ ì…ë ¥] í…ìŠ¤íŠ¸ë§Œ ì œê±° (ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë‚´ìš©ì€ ë³´ì¡´)
                if (currentItem.result && currentItem.result.text && currentItem.result.text.includes('[ìë™ ì…ë ¥]')) {
                    currentItem.result.text = '';
                }
                delete currentItem.branchActionTaken;
                
                // 3. í˜„ì¬ í•­ëª©ì´ ê±´ë„ˆë›°ì–´ì ¸ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ë³µêµ¬
                // (ë‹¤ë¥¸ ë¶„ê¸°ì— ì˜í•´ ê±´ë„ˆë›°ì–´ì§„ ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´)
                if (currentItem.skipped && currentItem.skipReason && currentItem.skipReason.startsWith(label)) {
                    delete currentItem.skipped;
                    delete currentItem.skipReason;
                }
                
                // 4. completedë¥¼ í™•ì‹¤íˆ falseë¡œ ì„¤ì • (boolean íƒ€ì… ë³´ì¥)
                // ì´ ë¶€ë¶„ì„ ë§ˆì§€ë§‰ì— ì‹¤í–‰í•˜ì—¬ ë¶„ê¸° ë²„íŠ¼ì´ ë‹¤ì‹œ ë‚˜íƒ€ë‚˜ë„ë¡ í•¨
                currentItem.completed = false;
                currentItem.completedAt = null;

                this.saveWorkflow(workflow);
                this.showToast('success', 'â†©ï¸', 'ë¶„ê¸° ì²˜ë¦¬ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                if (this.currentWorkflowId === workflowId) {
                    setTimeout(() => {
                        this.showChecklist(workflowId);
                    }, 100);
                } else {
                    this.displayWorkflows();
                }
            }

            async deleteWorkflow(workflowId) {
                if (!confirm('ì´ ì—…ë¬´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    return;
                }

                try {
                    // IndexedDBì—ì„œ ì‚­ì œ
                    const transaction = this.dbManager.db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    await new Promise((resolve, reject) => {
                        const request = store.delete(workflowId);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });

                    // ë©”ëª¨ë¦¬ì—ì„œ ì‚­ì œ
                    this.allData.workflows = this.allData.workflows.filter(w => w.id !== workflowId);
                    this.lastImportedWorkflowIds = this.lastImportedWorkflowIds.filter(id => id !== workflowId);

                    this.displayWorkflows();
                    this.showToast('success', 'âœ…', 'ì—…ë¬´ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
                } catch (error) {
                    console.error('ì—…ë¬´ ì‚­ì œ ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ì‚­ì œ ì‹¤íŒ¨: ' + error.message);
                }
            }

            // API í‚¤ ì•”í˜¸í™” (AES-GCM)
            async encryptApiKey(text) {
                if (!text) return '';
                try {
                    // ê³ ì • ì•”í˜¸í™” í‚¤ (32ë°”ì´íŠ¸ - AES-256ìš©)
                    const keyString = 'workflow-manager-api-key-2024-secret';
                    const keyBytes = new TextEncoder().encode(keyString.padEnd(32, '0').substring(0, 32));
                    
                    const key = await crypto.subtle.importKey(
                        'raw',
                        keyBytes,
                        { name: 'AES-GCM' },
                        false,
                        ['encrypt']
                    );
                    
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encoded = new TextEncoder().encode(text);
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encoded
                    );
                    
                    // IV + ì•”í˜¸í™”ëœ ë°ì´í„°ë¥¼ base64ë¡œ ì¸ì½”ë”©
                    const combined = new Uint8Array(iv.length + encrypted.byteLength);
                    combined.set(iv, 0);
                    combined.set(new Uint8Array(encrypted), iv.length);
                    
                    return btoa(String.fromCharCode.apply(null, combined));
                } catch (error) {
                    console.error('API í‚¤ ì•”í˜¸í™” ì˜¤ë¥˜:', error);
                    return text; // ì•”í˜¸í™” ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
                }
            }

            // API í‚¤ ë³µí˜¸í™” (AES-GCM)
            async decryptApiKey(encryptedText) {
                if (!encryptedText) return '';
                
                try {
                    // í‰ë¬¸ í‚¤ì¸ ê²½ìš° (ê¸°ì¡´ í˜¸í™˜ì„±) - base64 í˜•ì‹ì´ ì•„ë‹ˆê±°ë‚˜ ì§§ì€ ê²½ìš°
                    if (encryptedText.length < 20 || !encryptedText.match(/^[A-Za-z0-9+/=]+$/)) {
                        return encryptedText;
                    }
                    
                    const combined = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));
                    
                    // IVê°€ ì—†ìœ¼ë©´ í‰ë¬¸ìœ¼ë¡œ ê°„ì£¼
                    if (combined.length < 12) {
                        return encryptedText;
                    }
                    
                    const iv = combined.slice(0, 12);
                    const encrypted = combined.slice(12);
                    
                    // ê³ ì • ì•”í˜¸í™” í‚¤ (encryptApiKeyì™€ ë™ì¼)
                    const keyString = 'workflow-manager-api-key-2024-secret';
                    const keyBytes = new TextEncoder().encode(keyString.padEnd(32, '0').substring(0, 32));
                    
                    const key = await crypto.subtle.importKey(
                        'raw',
                        keyBytes,
                        { name: 'AES-GCM' },
                        false,
                        ['decrypt']
                    );
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encrypted
                    );
                    
                    return new TextDecoder().decode(decrypted);
                } catch (error) {
                    // ë³µí˜¸í™” ì‹¤íŒ¨ ì‹œ í‰ë¬¸ìœ¼ë¡œ ê°„ì£¼ (ê¸°ì¡´ í˜¸í™˜ì„± - Base64ë¡œ ì €ì¥ëœ ê²½ìš°)
                    try {
                        return atob(encryptedText);
                    } catch (e) {
                        return encryptedText;
                    }
                }
            }

            showToast(type, icon, message) {
                const toast = document.getElementById('toast');
                if (!toast) return;

                toast.textContent = `${icon} ${message}`;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // í”„ë¡œì íŠ¸ ë¬¸ì„œ ê°€ì ¸ì˜¤ê¸°
            async getProjectDocs(projectId) {
                try {
                    const docs = await this.dbManager.getPdfDocumentsByProject(projectId);
                    if (docs && docs.length > 0) {
                        return docs.map(doc => ({
                            filename: doc.filename,
                            content: doc.content,
                            parsedAt: doc.parsedAt,
                            pageCount: doc.pageCount,
                            summary: doc.summary
                        }));
                    }
                } catch (error) {
                    console.error('ë¬¸ì„œ ë¡œë“œ ì˜¤ë¥˜:', error);
                }
                return [];
            }

            // ê´€ë ¨ë„ ë†’ì€ ë¬¸ì„œ ì„ íƒ
            selectRelevantDocs(docs, checklistItems, maxCount = 1) {
                if (!docs || docs.length === 0) return [];
                if (docs.length <= maxCount) return docs;
                
                // í‚¤ì›Œë“œ ì¶”ì¶œ
                const keywords = this.extractKeywords(checklistItems);
                
                // ê´€ë ¨ë„ ê³„ì‚° ë° ì •ë ¬
                const docsWithScore = docs.map(doc => ({
                    doc: doc,
                    score: this.calculateRelevance(doc, keywords)
                }));
                
                // ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
                docsWithScore.sort((a, b) => b.score - a.score);
                
                // ìƒìœ„ ë¬¸ì„œ ë°˜í™˜
                return docsWithScore.slice(0, maxCount).map(item => item.doc);
            }

            // ë¬¸ì„œ ê´€ë ¨ë„ ê³„ì‚°
            calculateRelevance(doc, keywords) {
                if (!keywords || keywords.length === 0) return 0;
                if (!doc) return 0;
                
                let score = 0;
                const docText = (doc.filename || '') + ' ' + (doc.content || '') + ' ' + (doc.summary || '');
                const lowerDocText = docText.toLowerCase();
                
                keywords.forEach(keyword => {
                    const lowerKeyword = keyword.toLowerCase();
                    if (doc.filename && doc.filename.toLowerCase().includes(lowerKeyword)) {
                        score += 10;
                    }
                    if (doc.summary && doc.summary.toLowerCase().includes(lowerKeyword)) {
                        score += 5;
                    }
                    if (lowerDocText.includes(lowerKeyword)) {
                        score += 1;
                    }
                });
                
                return score;
            }

            // í‚¤ì›Œë“œ ì¶”ì¶œ
            extractKeywords(checklistItems) {
                if (!checklistItems || !Array.isArray(checklistItems)) return [];
                
                const keywords = new Set();
                
                checklistItems.forEach(item => {
                    if (!item || !item.text) return;
                    
                    const text = item.text;
                    const koreanNouns = text.match(/[ê°€-í£]{2,}/g);
                    if (koreanNouns) {
                        koreanNouns.forEach(noun => {
                            if (noun.length >= 2 && noun.length <= 10) {
                                keywords.add(noun);
                            }
                        });
                    }
                });
                
                return Array.from(keywords).slice(0, 20);
            }

            // ìŠ¤ë§ˆíŠ¸ ë¬¸ì„œ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
            async getSmartDocContext(doc, questionText, workflowId, apiKey, provider, model) {
                // ê¸°ì¡´ ìš”ì•½ì´ ìˆìœ¼ë©´ ì‚¬ìš©
                if (doc.summary && doc.summary.trim().length > 0) {
                    return doc.summary;
                }
                
                // ì§ˆë¬¸ì´ êµ¬ì²´ì ì¸ì§€ íŒë‹¨
                const isSpecificQuestion = questionText && (
                    questionText.includes('ì œ') && questionText.match(/\d+ì¡°/) ||
                    questionText.match(/\d+ì¼/) ||
                    questionText.length < 30
                );
                
                // êµ¬ì²´ì  ì§ˆë¬¸ì´ë©´ ê´€ë ¨ ë¶€ë¶„ ì¶”ì¶œ
                if (isSpecificQuestion && doc.content) {
                    const relevantText = this.extractRelevantText(doc.content, questionText, 2500);
                    if (relevantText.length > 200) {
                        return `[ì§ˆë¬¸ ê´€ë ¨ ë¶€ë¶„]\n${relevantText}`;
                    }
                }
                
                // ì¼ë°˜ ì§ˆë¬¸ ë˜ëŠ” ê´€ë ¨ ë¶€ë¶„ ì¶”ì¶œ ì‹¤íŒ¨: ì „ì²´ ë‚´ìš© ì‚¬ìš©
                return doc.content ? doc.content.substring(0, 2000) : '';
            }

            // ê´€ë ¨ í…ìŠ¤íŠ¸ ì¶”ì¶œ
            extractRelevantText(docContent, questionText, maxLength = 3000) {
                if (!docContent || !questionText) {
                    return docContent ? docContent.substring(0, maxLength) : '';
                }
                
                const keywords = this.extractKeywords([{ text: questionText }]);
                if (keywords.length === 0) {
                    return docContent.substring(0, maxLength);
                }
                
                // ë¬¸ì„œë¥¼ ë¬¸ë‹¨ ë‹¨ìœ„ë¡œ ë¶„í• 
                const paragraphs = docContent.split(/\n\n+/).filter(p => p.trim().length > 20);
                
                // ê° ë¬¸ë‹¨ì˜ ê´€ë ¨ë„ ì ìˆ˜ ê³„ì‚°
                const scoredParagraphs = paragraphs.map(para => {
                    let score = 0;
                    const lowerPara = para.toLowerCase();
                    
                    keywords.forEach(keyword => {
                        const lowerKeyword = keyword.toLowerCase();
                        const count = (lowerPara.match(new RegExp(lowerKeyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
                        score += count * 10;
                        
                        if (lowerPara.substring(0, 100).includes(lowerKeyword)) {
                            score += 20;
                        }
                    });
                    
                    return { text: para, score };
                });
                
                // ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
                scoredParagraphs.sort((a, b) => b.score - a.score);
                
                // ìƒìœ„ ê´€ë ¨ ë¬¸ë‹¨ë“¤ì„ ì„ íƒí•˜ì—¬ ê²°í•©
                let result = '';
                for (const para of scoredParagraphs) {
                    if (para.score === 0) break;
                    if (result.length + para.text.length > maxLength) {
                        const remaining = maxLength - result.length;
                        if (remaining > 100) {
                            result += para.text.substring(0, remaining) + '...\n\n';
                        }
                        break;
                    }
                    result += para.text + '\n\n';
                }
                
                // ê´€ë ¨ ë¶€ë¶„ì´ ì—†ê±°ë‚˜ ë„ˆë¬´ ì ìœ¼ë©´ ì „ì²´ ìš”ì•½ ì‚¬ìš©
                if (result.trim().length < 300) {
                    return docContent.substring(0, maxLength);
                }
                
                return result.trim();
            }
        }

        // ì•± ì´ˆê¸°í™”
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new MobileWorkflowManager();
            window.app = app;
        });

        // Service Worker ë“±ë¡ (PWA ì§€ì›)
        // Service WorkerëŠ” HTTPS ë˜ëŠ” localhostì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤
        // file:// í”„ë¡œí† ì½œì—ì„œëŠ” ì‘ë™í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ê±´ë„ˆëœë‹ˆë‹¤
        if ('serviceWorker' in navigator) {
            // file:// í”„ë¡œí† ì½œì¸ì§€ í™•ì¸
            const isFileProtocol = window.location.protocol === 'file:';
            
            if (!isFileProtocol) {
                window.addEventListener('load', () => {
                    // ìƒëŒ€ ê²½ë¡œ ì‚¬ìš© (GitHub Pages ì„œë¸Œ ë””ë ‰í† ë¦¬ ì§€ì›)
                    const swPath = './service-worker.js';
                    navigator.serviceWorker.register(swPath)
                        .then((registration) => {
                            console.log('âœ… Service Worker ë“±ë¡ ì„±ê³µ:', registration.scope);
                        })
                        .catch((error) => {
                            // file:// í”„ë¡œí† ì½œ ì˜¤ë¥˜ëŠ” ë¬´ì‹œ (ì •ìƒì ì¸ ë™ì‘)
                            if (!error.message.includes('URL protocol') && !error.message.includes('null')) {
                                console.log('âš ï¸ Service Worker ë“±ë¡ ì‹¤íŒ¨:', error);
                            }
                            // Service Worker ì‹¤íŒ¨í•´ë„ ì•±ì€ ì •ìƒ ì‘ë™
                        });
                });
            } else {
                // file:// í”„ë¡œí† ì½œì—ì„œëŠ” Service Workerë¥¼ ë“±ë¡í•˜ì§€ ì•ŠìŒ (ì •ìƒ ë™ì‘)
                // console.logëŠ” ì£¼ì„ ì²˜ë¦¬í•˜ì—¬ ì˜¤ë¥˜ ë°©ì§€
                // console.log('â„¹ï¸ Service WorkerëŠ” file:// í”„ë¡œí† ì½œì—ì„œ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. HTTPS ë˜ëŠ” localhostì—ì„œ ì‚¬ìš©í•˜ì„¸ìš”.');
            }
        }
    </script>
</body>
</html>
