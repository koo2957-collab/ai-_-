<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <link rel="manifest" href="manifest.json">
    <title>ğŸ“± ëª¨ë°”ì¼ ì—…ë¬´ ë„¤ë¹„ê²Œì´í„°</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #1a1a1a;
            --accent: #4a9eff;
            --success: #10b981;
            --white: #FFFFFF;
            --bg-light: #f8f9fa;
            --text-dark: #1a1a1a;
            --text-gray: #6c757d;
            --border-light: #dee2e6;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            font-family: -apple-system, 'Malgun Gothic', sans-serif;
            background: var(--bg-light);
            color: var(--text-dark);
            -webkit-font-smoothing: antialiased;
        }
        .header {
            background: linear-gradient(135deg, var(--primary), #2d2d2d);
            color: var(--white);
            padding: 15px 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: var(--shadow);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-title {
            font-size: 1.2rem;
            font-weight: 700;
        }
        .header-actions {
            display: flex;
            gap: 10px;
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            touch-action: manipulation;
        }
        .btn:active {
            transform: scale(0.95);
        }
        .btn-primary {
            background: var(--accent);
            color: var(--white);
        }
        .btn-secondary {
            background: #6c757d;
            color: var(--white);
        }
        .btn-success {
            background: var(--success);
            color: var(--white);
        }
        .btn-small {
            padding: 8px 12px;
            font-size: 0.85rem;
        }
        .main-content {
            padding: 20px;
            max-width: 100%;
        }
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-gray);
        }
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        .workflow-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .workflow-card {
            background: var(--white);
            border-radius: 12px;
            padding: 16px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .workflow-card:active {
            transform: scale(0.98);
        }
        .workflow-card.new-workflow {
            border: 2px solid var(--accent);
            background: linear-gradient(135deg, rgba(74, 158, 255, 0.05) 0%, rgba(74, 158, 255, 0.02) 100%);
        }
        .workflow-delete-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.1);
            border: none;
            color: #ef4444;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }
        .workflow-delete-btn:active {
            background: #ef4444;
            color: white;
            transform: scale(0.9);
        }
        .new-badge {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 700;
            margin-right: 8px;
        }
        .workflow-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-dark);
        }
        .workflow-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            font-size: 0.85rem;
            color: var(--text-gray);
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--success));
            transition: width 0.3s;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }
        .modal-content {
            background: var(--white);
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            margin: auto;
        }
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--white);
            z-index: 10;
        }
        .modal-title {
            font-size: 1.2rem;
            font-weight: 700;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .close-btn:active {
            background: var(--bg-light);
        }
        .modal-body {
            padding: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-light);
            border-radius: 8px;
            font-size: 0.95rem;
            font-family: inherit;
        }
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
        }
        .checklist-item {
            background: var(--white);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }
        .checklist-item.completed {
            opacity: 0.6;
        }
        .checklist-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .checklist-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .checklist-text {
            flex: 1;
            font-size: 0.95rem;
        }
        .checklist-text.completed {
            text-decoration: line-through;
            color: var(--text-gray);
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: var(--white);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 2000;
            display: none;
            font-size: 0.9rem;
        }
        .toast.show {
            display: block;
            animation: slideUp 0.3s ease;
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-light);
            border-radius: 8px;
            cursor: pointer;
        }
        .radio-option input[type="radio"] {
            width: 20px;
            height: 20px;
        }
        .ai-guide-content {
            white-space: pre-wrap;
            line-height: 1.8;
            color: var(--text-dark);
            font-size: 0.95rem;
        }
    </style>
</head>
<body>
    <!-- í—¤ë” -->
    <div class="header">
        <div class="header-content">
            <div class="header-title">ğŸ“± ì—…ë¬´ ë„¤ë¹„ê²Œì´í„°</div>
            <div class="header-actions">
                <button class="btn btn-secondary btn-small" onclick="app.openModal('settingsModal')">âš™ï¸ API</button>
                <button class="btn btn-primary btn-small" onclick="app.importProjectPackage()">ğŸ“¦ ê°€ì ¸ì˜¤ê¸°</button>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ ì½˜í…ì¸  -->
    <div class="main-content">
        <div id="workflowList" class="workflow-list">
            <div class="empty-state">
                <div class="empty-state-icon">ğŸ“­</div>
                <div>ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤</div>
                <div style="margin-top: 10px; font-size: 0.9rem; color: var(--text-gray);">
                    ìƒë‹¨ì˜ [ğŸ“¦ ê°€ì ¸ì˜¤ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬<br>ì—…ë¬´ íŒ¨í‚¤ì§€ë¥¼ ê°€ì ¸ì˜¤ì„¸ìš”
                </div>
            </div>
        </div>
    </div>

    <!-- API ì„¤ì • ëª¨ë‹¬ -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">âš™ï¸ AI ì„¤ì •</div>
                <button class="close-btn" onclick="app.closeModal('settingsModal')">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">ğŸ”Œ AI ì„œë¹„ìŠ¤ ì„ íƒ</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="provider-gemini" name="provider" value="gemini" checked onchange="app.selectProvider('gemini')">
                            <label for="provider-gemini">âš¡ Gemini</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="provider-chatgpt" name="provider" value="chatgpt" onchange="app.selectProvider('chatgpt')">
                            <label for="provider-chatgpt">ğŸ¤– ChatGPT</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="provider-claude" name="provider" value="claude" onchange="app.selectProvider('claude')">
                            <label for="provider-claude">ğŸ§  Claude</label>
                        </div>
                    </div>
                </div>

                <div id="geminiSettings">
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ¤– ëª¨ë¸ ì„ íƒ
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (ì¶”ì²œ: Gemini 2.5 Flash)
                            </span>
                        </label>
                        <select class="form-select" id="geminiModelSelect" onchange="app.selectModel('gemini', this.value)">
                            <option value="gemini-2.5-flash">âš¡ Gemini 2.5 Flash (ì¶”ì²œ, ë¬´ë£Œë“±ê¸‰ 1ì¼ 20íšŒ)</option>
                            <option value="gemini-2.5-flash-lite">âš¡ Gemini 2.5 Flash Lite (ë¬´ë£Œë“±ê¸‰ 1ì¼ 20íšŒ)</option>
                            <option value="gemini-2.0-flash">ğŸš€ Gemini 2.0 Flash (ì¼ì¼ ë¬´ì œí•œ, RPM 2K)</option>
                            <option value="gemini-2.0-flash-lite">âš¡ Gemini 2.0 Flash Lite (ì¼ì¼ ë¬´ì œí•œ, RPM 4K)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ”‘ API Key
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (Google AI Studioì—ì„œ ë°œê¸‰)
                            </span>
                        </label>
                        <input type="password" class="form-input" id="geminiApiKeyInput" placeholder="AIzaë¡œ ì‹œì‘í•˜ëŠ” í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                            <span id="geminiApiKeyStatus" style="color: var(--text-gray);"></span>
                            <button class="btn btn-secondary btn-small" onclick="app.resetApiKeyInput('gemini')">ğŸ”‘ í‚¤ ë³€ê²½</button>
                        </div>
                    </div>
                </div>

                <div id="chatgptSettings" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ¤– ëª¨ë¸ ì„ íƒ
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (ë¹ ë¥¸ ì‘ì—…ìš©)
                            </span>
                        </label>
                        <select class="form-select" id="chatgptModelSelect" onchange="app.selectModel('chatgpt', this.value)">
                            <option value="gpt-4o-mini">âš¡ GPT-4o-mini (ë¹ ë¥¸ ì‘ì—…, ì¶”ì²œ)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ”‘ API Key
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (OpenAI Platformì—ì„œ ë°œê¸‰)
                            </span>
                        </label>
                        <input type="password" class="form-input" id="chatgptApiKeyInput" placeholder="sk-ë¡œ ì‹œì‘í•˜ëŠ” í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                            <span id="chatgptApiKeyStatus" style="color: var(--text-gray);"></span>
                            <button class="btn btn-secondary btn-small" onclick="app.resetApiKeyInput('chatgpt')">ğŸ”‘ í‚¤ ë³€ê²½</button>
                        </div>
                    </div>
                </div>

                <div id="claudeSettings" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ¤– ëª¨ë¸ ì„ íƒ
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (ë¹ ë¥¸ ì‘ì—… / ê³ ê¸‰ ë¶„ì„)
                            </span>
                        </label>
                        <select class="form-select" id="claudeModelSelect" onchange="app.selectModel('claude', this.value)">
                            <option value="claude-3-5-haiku-20241022">âš¡ Claude 3.5 Haiku (ë¹ ë¥¸ ì‘ì—…, ì¶”ì²œ)</option>
                            <option value="claude-sonnet-4-20250514">ğŸ§  Claude Sonnet 4 (ê³ ê¸‰ ë¶„ì„)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            ğŸ”‘ API Key
                            <span style="font-size: 0.8rem; color: var(--text-gray); font-weight: normal; margin-left: 8px;">
                                (Anthropic Consoleì—ì„œ ë°œê¸‰)
                            </span>
                        </label>
                        <input type="password" class="form-input" id="claudeApiKeyInput" placeholder="sk-ant-ë¡œ ì‹œì‘í•˜ëŠ” í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”...">
                        <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                            <span id="claudeApiKeyStatus" style="color: var(--text-gray);"></span>
                            <button class="btn btn-secondary btn-small" onclick="app.resetApiKeyInput('claude')">ğŸ”‘ í‚¤ ë³€ê²½</button>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 24px; padding-top: 20px; border-top: 2px solid var(--border-light);">
                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                        <button class="btn btn-success" style="flex: 1;" onclick="app.saveApiKey()">ğŸ’¾ ì €ì¥</button>
                        <button class="btn btn-primary" style="flex: 1;" onclick="app.testApiConnection()">ğŸ§ª ì—°ê²° í…ŒìŠ¤íŠ¸</button>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--text-gray); text-align: center; line-height: 1.5;">
                        âœ… API í‚¤ëŠ” ë¡œì»¬ì— ì•ˆì „í•˜ê²Œ ì €ì¥ë©ë‹ˆë‹¤<br>
                        ğŸ’¡ ë¨¼ì € [ì—°ê²° í…ŒìŠ¤íŠ¸]ë¡œ í™•ì¸ í›„ [ì €ì¥]í•˜ì„¸ìš”
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ì²´í¬ë¦¬ìŠ¤íŠ¸ ë³´ê¸° ëª¨ë‹¬ -->
    <div class="modal" id="checklistModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="checklistModalTitle">ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸</div>
                <button class="close-btn" onclick="app.closeModal('checklistModal')">Ã—</button>
            </div>
            <div class="modal-body" id="checklistModalBody">
                <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
            </div>
        </div>
    </div>

    <!-- AI ê¸¸ì•ˆë‚´ ëª¨ë‹¬ -->
    <div class="modal" id="aiGuideModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ğŸ’¡ AI ê¸¸ì¡ì´</div>
                <button class="close-btn" onclick="app.closeModal('aiGuideModal')">Ã—</button>
            </div>
            <div class="modal-body">
                <div id="aiGuideContent" class="ai-guide-content">
                    <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                </div>
            </div>
        </div>
    </div>

    <!-- Toast ì•Œë¦¼ -->
    <div class="toast" id="toast"></div>

    <script>
        // IndexedDB ê´€ë¦¬ í´ë˜ìŠ¤
        class IndexedDBManager {
            constructor() {
                this.dbName = 'WorkflowDB';
                this.version = 2;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('projectFiles')) {
                            const projectStore = db.createObjectStore('projectFiles', { keyPath: 'id', autoIncrement: true });
                            projectStore.createIndex('projectKey', 'projectKey', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('formFiles')) {
                            const formStore = db.createObjectStore('formFiles', { keyPath: 'id', autoIncrement: true });
                            formStore.createIndex('detailKey', 'detailKey', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('projects')) {
                            const projectStore = db.createObjectStore('projects', { keyPath: 'id' });
                            projectStore.createIndex('title', 'title', { unique: false });
                            projectStore.createIndex('createdAt', 'createdAt', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('checklistDetails')) {
                            const detailStore = db.createObjectStore('checklistDetails', { keyPath: 'key' });
                            detailStore.createIndex('projectId', 'projectId', { unique: false });
                        }

                        if (!db.objectStoreNames.contains('pdfDocuments')) {
                            const pdfStore = db.createObjectStore('pdfDocuments', { keyPath: 'id', autoIncrement: true });
                            pdfStore.createIndex('projectId', 'projectId', { unique: false });
                            pdfStore.createIndex('fileName', 'fileName', { unique: false });
                            pdfStore.createIndex('parsedAt', 'parsedAt', { unique: false });
                        }
                    };
                });
            }

            async saveProject(project) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                if (!project.id) throw new Error('ì—…ë¬´ IDê°€ í•„ìš”í•©ë‹ˆë‹¤');
                
                project.updatedAt = new Date().toISOString();
                if (!project.createdAt) project.createdAt = project.updatedAt;
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    const request = store.put(project);
                    request.onsuccess = () => resolve(project.id);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllProjects() {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['projects'], 'readonly');
                    const store = transaction.objectStore('projects');
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveFile(storeName, fileData) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add(fileData);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveChecklistDetails(key, details) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['checklistDetails'], 'readwrite');
                    const store = transaction.objectStore('checklistDetails');
                    const request = store.put({ key, ...details });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getChecklistDetails(key) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['checklistDetails'], 'readonly');
                    const store = transaction.objectStore('checklistDetails');
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(request.error);
                });
            }

            async getPdfDocumentsByProject(projectId) {
                if (!this.db) throw new Error('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['pdfDocuments'], 'readonly');
                    const store = transaction.objectStore('pdfDocuments');
                    const index = store.index('projectId');
                    const request = index.getAll(projectId);
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // ëª¨ë°”ì¼ ì—…ë¬´ ê´€ë¦¬ì
        class MobileWorkflowManager {
            constructor() {
                this.API_KEY_STORAGE = 'apiKeys_v5.1';
                this.allData = {
                    workflows: [],
                    provider: 'gemini',
                    geminiApiKey: '',
                    chatgptApiKey: '',
                    claudeApiKey: '',
                    selectedModel: {
                        gemini: 'gemini-2.5-flash',
                        chatgpt: 'gpt-4o-mini',
                        claude: 'claude-3-5-haiku-20241022'
                    }
                };
                this.checklistDetails = {};
                this.dbManager = new IndexedDBManager();
                this.tempImportData = null;
                this.currentWorkflowId = null;
                this.currentItemIndex = null;
                this.lastImportedWorkflowIds = []; // ìµœê·¼ ê°€ì ¸ì˜¨ ì—…ë¬´ ID ëª©ë¡
                this.init();
            }

            async init() {
                try {
                    await this.dbManager.init();
                    await this.loadData();
                    await this.loadApiKeys();
                    this.displayWorkflows();
                } catch (error) {
                    console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ì´ˆê¸°í™” ì‹¤íŒ¨: ' + error.message);
                }
            }

            async loadData() {
                try {
                    const projects = await this.dbManager.getAllProjects();
                    this.allData.workflows = projects;
                    
                    // ì²´í¬ë¦¬ìŠ¤íŠ¸ ì„¸ë¶€ ì •ë³´ ë¡œë“œ
                    for (const workflow of projects) {
                        const projectKey = `project-${workflow.id}`;
                        const details = await this.dbManager.getChecklistDetails(projectKey);
                        if (details) {
                            this.checklistDetails[projectKey] = details;
                        }
                    }
                } catch (error) {
                    console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                }
            }

            async loadApiKeys() {
                const apiKeys = localStorage.getItem(this.API_KEY_STORAGE);
                if (apiKeys) {
                    try {
                        const keys = JSON.parse(apiKeys);
                        // ì•”í˜¸í™”ëœ í‚¤ ë³µí˜¸í™”
                        this.allData.geminiApiKey = await this.decryptApiKey(keys.gemini || '');
                        this.allData.chatgptApiKey = await this.decryptApiKey(keys.chatgpt || '');
                        this.allData.claudeApiKey = await this.decryptApiKey(keys.claude || '');
                    } catch (e) {
                        console.error('API í‚¤ ë¡œë“œ ì˜¤ë¥˜:', e);
                    }
                }
                
                const appSettings = localStorage.getItem('appSettings_v5.2');
                if (appSettings) {
                    try {
                        const settings = JSON.parse(appSettings);
                        if (settings.provider) this.allData.provider = settings.provider;
                        if (settings.selectedModel) this.allData.selectedModel = settings.selectedModel;
                    } catch (e) {
                        console.error('ì„¤ì • ë¡œë“œ ì˜¤ë¥˜:', e);
                    }
                }
                
                this.updateApiKeyInputs();
            }

            updateApiKeyInputs() {
                const provider = this.allData.provider;
                document.getElementById('provider-' + provider).checked = true;
                this.selectProvider(provider);
                
                const geminiInput = document.getElementById('geminiApiKeyInput');
                const chatgptInput = document.getElementById('chatgptApiKeyInput');
                const claudeInput = document.getElementById('claudeApiKeyInput');
                
                if (geminiInput) {
                    geminiInput.value = this.allData.geminiApiKey ? 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.' : '';
                }
                if (chatgptInput) {
                    chatgptInput.value = this.allData.chatgptApiKey ? 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.' : '';
                }
                if (claudeInput) {
                    claudeInput.value = this.allData.claudeApiKey ? 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.' : '';
                }
            }

            displayWorkflows() {
                const container = document.getElementById('workflowList');
                if (!container) return;

                if (this.allData.workflows.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“­</div>
                            <div>ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤</div>
                            <div style="margin-top: 10px; font-size: 0.9rem; color: var(--text-gray);">
                                ìƒë‹¨ì˜ [ğŸ“¦ ê°€ì ¸ì˜¤ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬<br>ì—…ë¬´ íŒ¨í‚¤ì§€ë¥¼ ê°€ì ¸ì˜¤ì„¸ìš”
                            </div>
                        </div>
                    `;
                    return;
                }

                // ì—…ë¬´ ì •ë ¬: ìµœê·¼ ê°€ì ¸ì˜¨ ì—…ë¬´ê°€ ìƒë‹¨ì—
                const sortedWorkflows = [...this.allData.workflows].sort((a, b) => {
                    const importA = a.importedAt ? new Date(a.importedAt).getTime() : 0;
                    const importB = b.importedAt ? new Date(b.importedAt).getTime() : 0;
                    
                    // ë‘˜ ë‹¤ ê°€ì ¸ì˜¨ ê¸°ë¡ì´ ì—†ìœ¼ë©´ ìµœì‹ ìˆœ(ì‘ì„±ì¼)ìœ¼ë¡œ 2ì°¨ ì •ë ¬
                    if (importA === 0 && importB === 0) {
                        const dateA = a.createdAt ? new Date(a.createdAt) : new Date(a.date || 0);
                        const dateB = b.createdAt ? new Date(b.createdAt) : new Date(b.date || 0);
                        return dateB - dateA;
                    }
                    return importB - importA;
                });

                container.innerHTML = sortedWorkflows.map(workflow => {
                    const progress = this.calculateProgress(workflow);
                    const checklistCount = workflow.checklist ? workflow.checklist.length : 0;
                    const completedCount = workflow.checklist ? workflow.checklist.filter(c => this.normalizeCompleted(c)).length : 0;
                    const isNew = this.lastImportedWorkflowIds.includes(workflow.id);
                    const cardClass = isNew ? 'workflow-card new-workflow' : 'workflow-card';
                    const newBadge = isNew ? '<span class="new-badge">NEW</span>' : '';
                    
                    return `
                        <div class="${cardClass}" onclick="app.showChecklist(${workflow.id})">
                            <button class="workflow-delete-btn" onclick="event.stopPropagation(); app.deleteWorkflow(${workflow.id})" title="ì‚­ì œ">ğŸ—‘ï¸</button>
                            <div class="workflow-title">${newBadge}${this.escapeHtml(workflow.title)}</div>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <div class="workflow-meta">
                                <span>âœ… ${completedCount}/${checklistCount}</span>
                                <span>${progress}%</span>
                                <span>${workflow.date || ''}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            calculateProgress(workflow) {
                if (!workflow.checklist || workflow.checklist.length === 0) {
                    return workflow.completedDate ? 100 : 0;
                }
                const completed = workflow.checklist.filter(item => this.normalizeCompleted(item)).length;
                return Math.round((completed / workflow.checklist.length) * 100);
            }

            normalizeCompleted(item) {
                if (item.completed === true || item.completed === 'true') return true;
                if (item.completed === false || item.completed === 'false') return false;
                return false;
            }

            showChecklist(workflowId) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow) return;

                this.currentWorkflowId = workflowId;
                const title = document.getElementById('checklistModalTitle');
                const body = document.getElementById('checklistModalBody');
                
                if (title) title.textContent = `ğŸ“‹ ${this.escapeHtml(workflow.title)}`;
                
                if (!workflow.checklist || workflow.checklist.length === 0) {
                    if (body) {
                        body.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-gray);">ì²´í¬ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                    }
                } else {
                    if (body) {
                        body.innerHTML = workflow.checklist.map((item, index) => {
                            const isCompleted = this.normalizeCompleted(item);
                            return `
                                <div class="checklist-item ${isCompleted ? 'completed' : ''}">
                                    <div class="checklist-item-header">
                                        <input type="checkbox" class="checklist-checkbox" ${isCompleted ? 'checked' : ''} 
                                               onchange="app.toggleChecklistItem(${workflowId}, ${index})">
                                        <span class="checklist-text ${isCompleted ? 'completed' : ''}">
                                            ${this.escapeHtml(item.text || '')}
                                        </span>
                                        <button class="btn btn-primary btn-small" onclick="app.showAIGuide(${workflowId}, ${index})">
                                            ğŸ’¡ AI
                                        </button>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    }
                }
                
                this.openModal('checklistModal');
            }

            toggleChecklistItem(workflowId, itemIndex) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow || !workflow.checklist) return;

                const item = workflow.checklist[itemIndex];
                if (!item) return;

                item.completed = !this.normalizeCompleted(item);
                if (item.completed) {
                    item.completedAt = new Date().toISOString();
                } else {
                    item.completedAt = null;
                }

                this.saveWorkflow(workflow);
                this.displayWorkflows();
                
                // ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸
                if (this.currentWorkflowId === workflowId) {
                    this.showChecklist(workflowId);
                }
            }

            async showAIGuide(workflowId, itemIndex) {
                const workflow = this.allData.workflows.find(w => w.id === workflowId);
                if (!workflow || !workflow.checklist) return;

                const item = workflow.checklist[itemIndex];
                if (!item) return;

                this.currentWorkflowId = workflowId;
                this.currentItemIndex = itemIndex;

                const provider = this.allData.provider;
                let apiKey;
                if (provider === 'gemini') {
                    apiKey = this.allData.geminiApiKey;
                } else if (provider === 'chatgpt') {
                    apiKey = this.allData.chatgptApiKey;
                } else if (provider === 'claude') {
                    apiKey = this.allData.claudeApiKey;
                }

                if (!apiKey) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”');
                    return;
                }

                this.showToast('info', 'â³', 'AI ê¸¸ì¡ì´ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘...');

                try {
                    const prompt = await this.buildAIGuidePrompt(workflow, item, itemIndex);
                    const helpText = await this.callAI(prompt);
                    const content = document.getElementById('aiGuideContent');
                    if (content) {
                        content.textContent = helpText;
                    }
                    this.openModal('aiGuideModal');
                    this.showToast('success', 'âœ…', 'AI ê¸¸ì¡ì´ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤');
                } catch (error) {
                    this.showToast('error', 'âŒ', 'AI í˜¸ì¶œ ì‹¤íŒ¨: ' + error.message);
                }
            }

            async buildAIGuidePrompt(workflow, item, itemIndex) {
                // í˜„ì¬ í•­ëª©ì˜ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const latestWorkflow = this.allData.workflows.find(w => w.id === workflow.id);
                let currentItem = item;
                if (latestWorkflow && latestWorkflow.checklist && latestWorkflow.checklist[itemIndex]) {
                    currentItem = latestWorkflow.checklist[itemIndex];
                }

                // ì—…ë¬´ ì •ë³´
                let prompt = `[ì—…ë¬´ ì •ë³´]\nì œëª©: ${workflow.title}\n`;
                if (workflow.content) {
                    prompt += `ë‚´ìš©: ${workflow.content}\n`;
                }

                // í˜„ì¬ í•­ëª© ì •ë³´
                prompt += `\n[í˜„ì¬ í•­ëª© ìƒì„¸ ì •ë³´]\n`;
                prompt += `í•­ëª©: ${currentItem.text}\n`;

                // ì²¨ë¶€ì„œì‹ í™•ì¸
                let hasFormats = false;
                let formatNames = '';
                if (currentItem.formats && Array.isArray(currentItem.formats) && currentItem.formats.length > 0) {
                    const formatList = currentItem.formats.map(f => {
                        if (typeof f === 'string') return f;
                        if (f && typeof f === 'object' && f.name) return f.name;
                        return String(f);
                    }).filter(name => name && name.trim());
                    
                    if (formatList.length > 0) {
                        hasFormats = true;
                        formatNames = formatList.join(', ');
                        prompt += `ğŸ“‹ ì²¨ë¶€ì„œì‹: ${formatNames}\n`;
                    }
                }
                if (!hasFormats) {
                    prompt += `ğŸ“‹ ì²¨ë¶€ì„œì‹: ì—†ìŒ\n`;
                }

                // ì €ì¥ëœ ì—…ë¬´íŒ
                if (currentItem.tip?.content && currentItem.tip.content.trim()) {
                    prompt += `ğŸ’¡ ì €ì¥ëœ ì—…ë¬´íŒ: ${currentItem.tip.content}\n`;
                }

                // checklistDetails ì •ë³´
                const detailKey = `${workflow.id}-${itemIndex}`;
                const details = this.checklistDetails[detailKey];
                if (details) {
                    if (details.tip && details.tip.trim()) {
                        prompt += `ğŸ’¡ ìƒì„¸ íŒ: ${details.tip}\n`;
                    }
                    if (details.details && details.details.trim()) {
                        prompt += `ğŸ“ ìƒì„¸ ì •ë³´: ${details.details}\n`;
                    }
                    if (details.law && details.law.trim()) {
                        prompt += `âš–ï¸ ë²•ë ¹ ì •ë³´: ${details.law}\n`;
                    }
                    if (details.memo && details.memo.trim()) {
                        prompt += `ğŸ“Œ ë©”ëª¨: ${details.memo}\n`;
                    }
                }
                prompt += '\n';

                // ì „ì²´ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì •ë³´
                let checklistContext = '';
                if (workflow.checklist && workflow.checklist.length > 0) {
                    checklistContext = '[ì „ì²´ ì²´í¬ë¦¬ìŠ¤íŠ¸]\n';
                    workflow.checklist.forEach((it, idx) => {
                        const isCurrent = idx === itemIndex;
                        const prefix = isCurrent ? 'ğŸ‘‰ í˜„ì¬: ' : `${idx + 1}. `;
                        let status = this.normalizeCompleted(it) ? ' âœ…' : ' â¬œ';
                        if (it.skipped) status = ' ğŸš« (ê±´ë„ˆëœ€)';
                        checklistContext += `${prefix}${it.text}${status}\n`;
                    });
                }

                // ì´ì „ ì™„ë£Œ í•­ëª©ì˜ ê²½í—˜/ê²°ê³¼
                let completedExperience = '';
                const completedItems = workflow.checklist.filter((it, idx) => 
                    idx < itemIndex && this.normalizeCompleted(it)
                );
                
                if (completedItems.length > 0) {
                    completedExperience = '[ì´ì „ ì™„ë£Œ í•­ëª©ì˜ ê²½í—˜/ê²°ê³¼]\n';
                    completedItems.slice(-3).forEach((it, idx) => {
                        completedExperience += `${idx + 1}. ${it.text}\n`;
                        if (it.result?.summary) {
                            completedExperience += `   ğŸ¤– ê²°ê³¼: ${it.result.summary}\n`;
                        }
                        if (it.tip?.content) {
                            completedExperience += `   ğŸ’¡ íŒ: ${it.tip.content}\n`;
                        }
                    });
                    completedExperience += '\n';
                }

                // ì°¸ì¡° ë¬¸ì„œ (PDF ë¬¸ì„œ)
                let docContext = '';
                try {
                    const docs = await this.getProjectDocs(workflow.id);
                    if (docs && docs.length > 0) {
                        const relevantDocs = this.selectRelevantDocs(docs, workflow.checklist, 1);
                        const selectedDoc = relevantDocs.length > 0 ? relevantDocs[0] : docs[0];
                        
                        if (selectedDoc) {
                            const provider = this.allData.provider;
                            const model = this.allData.selectedModel[provider];
                            let apiKey;
                            if (provider === 'gemini') {
                                apiKey = this.allData.geminiApiKey;
                            } else if (provider === 'chatgpt') {
                                apiKey = this.allData.chatgptApiKey;
                            } else if (provider === 'claude') {
                                apiKey = this.allData.claudeApiKey;
                            }
                            
                            if (apiKey) {
                                try {
                                    const questionText = currentItem.text || '';
                                    docContext = await this.getSmartDocContext(selectedDoc, questionText, workflow.id, apiKey, provider, model);
                                } catch (error) {
                                    console.error('ë¬¸ì„œ ìš”ì•½ ì˜¤ë¥˜:', error);
                                    docContext = selectedDoc.content ? selectedDoc.content.substring(0, 2000) : '';
                                }
                            } else if (selectedDoc.content) {
                                docContext = selectedDoc.content.substring(0, 2000);
                            }
                        }
                    }
                } catch (error) {
                    console.error('ë¬¸ì„œ ë¡œë“œ ì˜¤ë¥˜:', error);
                }

                // ë§ˆê°ì¼ ì •ë³´
                let deadlineInfo = '';
                if (workflow.deadline) {
                    const deadline = new Date(workflow.deadline);
                    const today = new Date();
                    const diffTime = deadline - today;
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    
                    if (diffDays > 0) {
                        deadlineInfo = `\n[ë§ˆê°ì¼ ì •ë³´]\n- ë§ˆê°ì¼: ${workflow.deadline}\n- ë‚¨ì€ ì¼ìˆ˜: ${diffDays}ì¼\n`;
                    } else if (diffDays === 0) {
                        deadlineInfo = `\n[ë§ˆê°ì¼ ì •ë³´]\n- ë§ˆê°ì¼: ${workflow.deadline}\n- âš ï¸ ì˜¤ëŠ˜ ë§ˆê°ì…ë‹ˆë‹¤!\n`;
                    } else {
                        deadlineInfo = `\n[ë§ˆê°ì¼ ì •ë³´]\n- ë§ˆê°ì¼: ${workflow.deadline}\n- âš ï¸ ë§ˆê°ì¼ì´ ì§€ë‚¬ìŠµë‹ˆë‹¤ (${Math.abs(diffDays)}ì¼ ê²½ê³¼)\n`;
                    }
                }

                // ì§„í–‰ë¥  ê³„ì‚°
                const progress = this.calculateProgress(workflow);
                const completedCount = workflow.checklist.filter(it => this.normalizeCompleted(it)).length;
                const isCurrentCompleted = this.normalizeCompleted(currentItem);

                // ìµœì¢… í”„ë¡¬í”„íŠ¸ êµ¬ì„±
                const finalPrompt = `
[í˜„ì¬ ìƒí™©]
- ì—…ë¬´: ${workflow.title}
- ì§„í–‰ë¥ : ${progress}% (${completedCount}/${workflow.checklist.length} ì™„ë£Œ)
- í˜„ì¬ í•­ëª©: ${currentItem.text} ${isCurrentCompleted ? 'âœ…' : 'â¬œ'}

${completedExperience}

${prompt}

${checklistContext}

[ì°¸ì¡° ë¬¸ì„œ]
${docContext}${deadlineInfo}

ã€ì¤‘ìš” ì§€ì‹œì‚¬í•­ã€‘
1. í˜„ì¬ í•­ëª©ì— ì´ë¯¸ ì €ì¥ëœ ì •ë³´(ì—…ë¬´íŒ, ì²¨ë¶€ì„œì‹, ìƒì„¸ ì •ë³´)ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  í™œìš©í•˜ì„¸ìš”.
2. ì €ì¥ëœ ì •ë³´ê°€ ì—†ì„ ë•Œë§Œ AIê°€ ìƒˆë¡œ ìƒì„±í•˜ì„¸ìš”.
3. ì´ì „ ì™„ë£Œ í•­ëª©ì˜ ê²½í—˜ê³¼ ê²°ê³¼ë¥¼ ì°¸ê³ í•˜ì—¬ ë” ë‚˜ì€ ê°€ì´ë“œë¥¼ ì œê³µí•˜ì„¸ìš”.
4. ë§ˆê°ì¼ì´ ê°€ê¹Œìš°ë©´ ì‹œê°„ ê´€ë¦¬ì— ëŒ€í•œ ì¡°ì–¸ì„ í¬í•¨í•˜ì„¸ìš”.
5. ã€ë§¤ìš° ì¤‘ìš” - ì„œì‹ ì •ë³´ í™œìš©ã€‘ìœ„ì˜ "[í˜„ì¬ í•­ëª© ìƒì„¸ ì •ë³´]"ì— "ğŸ“‹ ì²¨ë¶€ì„œì‹" ì •ë³´ê°€ ìˆìœ¼ë©´, ë°˜ë“œì‹œ ê·¸ íŒŒì¼ëª…ë“¤ì„ "2ï¸âƒ£ í•„ìš”í•œ ì„œì‹Â·ì˜ˆì‹œ ë¬¸ì„œ" ì„¹ì…˜ì—ì„œ ì •í™•íˆ ì–¸ê¸‰í•˜ê³  ì•ˆë‚´í•˜ì„¸ìš”.
6. í˜„ì¬ í•­ëª©ì— ì²¨ë¶€ì„œì‹ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ "ë³„ë„ ì„œì‹ ì—†ì´ ì§„í–‰í•´ë„ ë©ë‹ˆë‹¤" ë˜ëŠ” "ê¸°ê´€ì—ì„œ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì¼ë°˜ ì–‘ì‹ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤" ì •ë„ë¡œë§Œ ì•ˆë‚´í•˜ì„¸ìš”.
7. ã€ë§¤ìš° ì¤‘ìš”ã€‘ë‹µë³€ì€ í•µì‹¬ë§Œ ê°„ê²°í•˜ê²Œ ì‘ì„±í•˜ì„¸ìš”. ê° ì„¹ì…˜ì€ 2-3ì¤„ë¡œ ìš”ì•½í•˜ê³ , ë¶ˆí•„ìš”í•œ ì„¤ëª…ì´ë‚˜ ë°˜ë³µì€ ìƒëµí•˜ì„¸ìš”.

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”:

1ï¸âƒ£ í˜„ì¬ í•  ì¼
- êµ¬ì²´ì ì¸ ì‘ì—… ë‚´ìš©
- í˜„ì¬ í•­ëª©: "${currentItem.text}"ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ ë‹¨ê³„ë³„ ê°€ì´ë“œ

2ï¸âƒ£ í•„ìš”í•œ ì„œì‹Â·ì˜ˆì‹œ ë¬¸ì„œ
${hasFormats && formatNames ? 
    `ã€ë°˜ë“œì‹œ ì´ ë‚´ìš©ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì„¸ìš”ã€‘
- ì²¨ë¶€ëœ ì„œì‹/ì˜ˆì‹œ ë¬¸ì„œ: ${formatNames}
- ì´ íŒŒì¼ë“¤ì€ "ì„œì‹ ì¶”ê°€í•˜ê¸°"ì—ì„œ ì´ë¯¸ ì—…ë¡œë“œë˜ì–´ ìˆìŠµë‹ˆë‹¤
- ì„œì‹ íŒŒì¼ì€ ë‚´ë ¤ë°›ì•„ ê·¸ëŒ€ë¡œ ì‘ì„±Â·ì œì¶œí•˜ì„¸ìš”
- ì˜ˆì‹œ ê³µë¬¸ íŒŒì¼ì€ í˜•ì‹ê³¼ í‘œí˜„ì„ ì°¸ê³ í•˜ì—¬ ìš°ë¦¬ ê¸°ê´€ ì–‘ì‹ì— ë§ê²Œ ìƒˆ ê³µë¬¸ì„ ì‘ì„±í•˜ì„¸ìš”` : 
    '- ìœ„ì˜ "[í˜„ì¬ í•­ëª© ìƒì„¸ ì •ë³´]"ë¥¼ í™•ì¸í•œ ê²°ê³¼, ì´ í•­ëª©ì—ëŠ” ë³„ë„ë¡œ ì²¨ë¶€ëœ ì„œì‹ì´ë‚˜ ì˜ˆì‹œ ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤. ë³„ë„ ì„œì‹ ì—†ì´ ì§„í–‰í•˜ê±°ë‚˜, ê¸°ê´€ì—ì„œ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ê¸°ë³¸ ì–‘ì‹ê³¼ ë¶€ì„œ ì§€ì¹¨ì— ë”°ë¼ ì§„í–‰í•˜ë¼ê³  ì•ˆë‚´í•˜ì„¸ìš”.'}

3ï¸âƒ£ ì£¼ì˜ì‚¬í•­
- ì €ì¥ëœ ì£¼ì˜ì‚¬í•­ë“¤ì„ ëª¨ë‘ ë‚˜ì—´í•˜ì„¸ìš”
${docContext && docContext.trim() ? '- [ì°¸ì¡° ë¬¸ì„œ]ì—ì„œ í˜„ì¬ í•­ëª©ê³¼ ê´€ë ¨ëœ ì£¼ì˜ì‚¬í•­ì„ ì¶”ì¶œí•˜ì—¬ ì¶”ê°€ë¡œ í¬í•¨í•˜ì„¸ìš”' : '- [ì°¸ì¡° ë¬¸ì„œ]ê°€ ì—†ìœ¼ë¯€ë¡œ ì €ì¥ëœ ì£¼ì˜ì‚¬í•­ë§Œ í‘œì‹œí•˜ê³  ì„ì˜ë¡œ ì¶”ê°€ ì£¼ì˜ì‚¬í•­ì„ ìƒì„±í•˜ì§€ ë§ˆì„¸ìš”'}

4ï¸âƒ£ ì˜ˆìƒ ì†Œìš”ì‹œê°„
- ì‹œê°„ ì˜ˆìƒ
${deadlineInfo ? `- ë§ˆê°ì¼ ê³ ë ¤: ${deadlineInfo.includes('ì˜¤ëŠ˜ ë§ˆê°') ? 'ì˜¤ëŠ˜ ë§ˆê°ì´ë¯€ë¡œ ì‹ ì†íˆ ì§„í–‰í•˜ì„¸ìš”' : deadlineInfo.includes('ì§€ë‚¬ìŠµë‹ˆë‹¤') ? 'ë§ˆê°ì¼ì´ ì§€ë‚¬ìœ¼ë¯€ë¡œ ì¦‰ì‹œ ì§„í–‰í•˜ì„¸ìš”' : 'ë§ˆê°ì¼ê¹Œì§€ ì‹œê°„ì„ ê³ ë ¤í•˜ì—¬ ê³„íší•˜ì„¸ìš”'}` : ''}
                `.trim();

                return finalPrompt;
            }

            async callAI(prompt) {
                const provider = this.allData.provider;
                const model = this.allData.selectedModel[provider];
                let apiKey;
                
                if (provider === 'gemini') {
                    apiKey = this.allData.geminiApiKey;
                    return await this.callGeminiAPI(apiKey, model, prompt);
                } else if (provider === 'chatgpt') {
                    apiKey = this.allData.chatgptApiKey;
                    return await this.callChatGPTAPI(apiKey, model, prompt);
                } else if (provider === 'claude') {
                    apiKey = this.allData.claudeApiKey;
                    return await this.callClaudeAPI(apiKey, model, prompt);
                }
            }

            async callGeminiAPI(apiKey, model, prompt) {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: prompt }]
                        }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ì˜¤ë¥˜: ${response.status}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }

            async callChatGPTAPI(apiKey, model, prompt) {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ì˜¤ë¥˜: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async callClaudeAPI(apiKey, model, prompt) {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: model,
                        max_tokens: 4096,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ì˜¤ë¥˜: ${response.status}`);
                }

                const data = await response.json();
                return data.content[0].text;
            }

            async saveWorkflow(workflow) {
                try {
                    await this.dbManager.saveProject(workflow);
                } catch (error) {
                    console.error('ì—…ë¬´ ì €ì¥ ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ì €ì¥ ì‹¤íŒ¨: ' + error.message);
                }
            }

            // ì—…ë¬´ ê°€ì ¸ì˜¤ê¸°
            importProjectPackage() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const packageData = JSON.parse(text);

                        if (packageData.type !== 'project' && packageData.type !== 'yearly-backup') {
                            throw new Error('ì˜¬ë°”ë¥¸ ì—…ë¬´ íŒ¨í‚¤ì§€ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.');
                        }

                        if (!packageData.projects || !Array.isArray(packageData.projects) || packageData.projects.length === 0) {
                            throw new Error('ê°€ì ¸ì˜¬ ì—…ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        }

                        this.tempImportData = packageData;
                        this.showImportModeModal();
                    } catch (error) {
                        console.error('íŒŒì¼ ì½ê¸° ì˜¤ë¥˜:', error);
                        this.showToast('error', 'âŒ', 'íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ' + error.message);
                    }
                };
                input.click();
            }

            showImportModeModal() {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                const projectCount = this.tempImportData.projects.length;
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ğŸ“¦ ì—…ë¬´ ê°€ì ¸ì˜¤ê¸°</div>
                            <button class="close-btn" onclick="this.closest('.modal').remove()">Ã—</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 20px; color: var(--text-gray);">
                                ê°€ì ¸ì˜¬ ì—…ë¬´: ${projectCount}ê°œ
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 15px;">
                                <button class="btn btn-primary" onclick="app.processImport('asIs')" style="padding: 20px; text-align: left;">
                                    <div style="font-weight: 600; margin-bottom: 8px;">ê·¸ëŒ€ë¡œ ê°€ì ¸ì˜¤ê¸°</div>
                                    <div style="font-size: 0.9rem; color: var(--text-gray);">ì›ë³¸ ë‚ ì§œì™€ ì²´í¬ ìƒíƒœë¥¼ ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤</div>
                                </button>
                                <button class="btn btn-secondary" onclick="app.processImport('new')" style="padding: 20px; text-align: left;">
                                    <div style="font-weight: 600; margin-bottom: 8px;">ìƒˆ ì—…ë¬´ë¡œ ì‹œì‘</div>
                                    <div style="font-size: 0.9rem; color: var(--text-gray);">ì˜¤ëŠ˜ ë‚ ì§œë¡œ ì„¤ì •í•˜ê³  ëª¨ë“  ì²´í¬ë¥¼ í•´ì œí•©ë‹ˆë‹¤</div>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            async processImport(mode) {
                const modal = document.querySelector('.modal.show');
                if (modal) modal.remove();

                if (!this.tempImportData) {
                    this.showToast('error', 'âŒ', 'ê°€ì ¸ì˜¬ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                const packageData = this.tempImportData;
                this.tempImportData = null;

                this.showToast('info', 'â³', 'íŒ¨í‚¤ì§€ ê°€ì ¸ì˜¤ëŠ” ì¤‘...');

                try {
                    const todayDate = new Date().toISOString().slice(0, 10);
                    const todayDateKR = new Date().toLocaleDateString('ko-KR');
                    let importedCount = 0;

                    for (const project of packageData.projects) {
                        if (!project || !project.id) continue;

                        const oldId = project.id;
                        project.id = Date.now() + Math.random();
                        project.importedAt = new Date().toISOString();
                        project.originalId = oldId;

                        if (mode === 'new') {
                            project.createdAt = todayDate;
                            project.date = todayDateKR;
                            if (project.checklist && Array.isArray(project.checklist)) {
                                project.checklist.forEach(item => {
                                    item.completed = false;
                                    item.completedAt = null;
                                });
                            }
                        }

                        await this.dbManager.saveProject(project);
                        this.allData.workflows.push(project);
                        this.lastImportedWorkflowIds.push(project.id);
                        importedCount++;

                        // ì²´í¬ë¦¬ìŠ¤íŠ¸ ì„¸ë¶€ ì •ë³´ ë³µì›
                        const projectKey = `project-${project.id}`;
                        if (packageData.files) {
                            for (const key in packageData.files) {
                                if (key.includes(`project-${oldId}-`)) {
                                    const fileInfo = packageData.files[key];
                                    if (fileInfo && fileInfo.data) {
                                        const blob = await this.base64ToBlob(fileInfo.data, fileInfo.type);
                                        const fileData = {
                                            projectKey: projectKey,
                                            fileName: fileInfo.name,
                                            fileType: fileInfo.type,
                                            fileSize: blob.size,
                                            blob: blob,
                                            uploadDate: new Date().toISOString()
                                        };
                                        await this.dbManager.saveFile('projectFiles', fileData);
                                    }
                                }
                            }
                        }
                    }

                    this.displayWorkflows();
                    
                    // 3ì´ˆ í›„ NEW ë±ƒì§€ ì œê±°
                    setTimeout(() => {
                        this.lastImportedWorkflowIds = [];
                        this.displayWorkflows();
                    }, 3000);
                    
                    this.showToast('success', 'âœ…', `ì—…ë¬´ ${importedCount}ê°œ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ`);
                } catch (error) {
                    console.error('ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message);
                }
            }

            base64ToBlob(base64, mimeType) {
                const byteCharacters = atob(base64.split(',')[1] || base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            }

            // API ì„¤ì •
            selectProvider(provider) {
                this.allData.provider = provider;
                document.getElementById('geminiSettings').style.display = provider === 'gemini' ? 'block' : 'none';
                document.getElementById('chatgptSettings').style.display = provider === 'chatgpt' ? 'block' : 'none';
                document.getElementById('claudeSettings').style.display = provider === 'claude' ? 'block' : 'none';
            }

            selectModel(provider, model) {
                this.allData.selectedModel[provider] = model;
            }

            resetApiKeyInput(provider) {
                const input = document.getElementById(provider + 'ApiKeyInput');
                if (input) {
                    input.value = '';
                    input.type = 'text';
                    input.focus();
                }
            }

            async saveApiKey() {
                const provider = this.allData.provider;
                const input = document.getElementById(provider + 'ApiKeyInput');
                if (!input) return;

                const apiKey = input.value.trim();
                if (!apiKey || apiKey.includes('âœ…')) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”');
                    return;
                }

                if (provider === 'gemini') {
                    this.allData.geminiApiKey = apiKey;
                } else if (provider === 'chatgpt') {
                    this.allData.chatgptApiKey = apiKey;
                } else if (provider === 'claude') {
                    this.allData.claudeApiKey = apiKey;
                }

                // API í‚¤ ì €ì¥ (AES-GCM ì•”í˜¸í™”)
                const keys = {
                    gemini: await this.encryptApiKey(this.allData.geminiApiKey),
                    chatgpt: await this.encryptApiKey(this.allData.chatgptApiKey),
                    claude: await this.encryptApiKey(this.allData.claudeApiKey)
                };
                localStorage.setItem(this.API_KEY_STORAGE, JSON.stringify(keys));

                // ì„¤ì • ì €ì¥
                const settings = {
                    provider: this.allData.provider,
                    selectedModel: this.allData.selectedModel
                };
                localStorage.setItem('appSettings_v5.2', JSON.stringify(settings));

                input.value = 'âœ… API Keyê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                input.type = 'password';
                
                // ëª¨ë‹¬ ë‹«ê¸°
                this.closeModal('settingsModal');
                this.showToast('success', 'âœ…', 'API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
            }

            async testApiConnection() {
                const provider = this.allData.provider;
                let apiKey;
                if (provider === 'gemini') {
                    apiKey = this.allData.geminiApiKey;
                } else if (provider === 'chatgpt') {
                    apiKey = this.allData.chatgptApiKey;
                } else if (provider === 'claude') {
                    apiKey = this.allData.claudeApiKey;
                }

                if (!apiKey) {
                    this.showToast('error', 'âš ï¸', 'API í‚¤ë¥¼ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”');
                    return;
                }

                this.showToast('info', 'â³', 'API ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘...');

                try {
                    await this.callAI('í…ŒìŠ¤íŠ¸');
                    this.showToast('success', 'âœ…', 'API ì—°ê²° ì„±ê³µ');
                } catch (error) {
                    this.showToast('error', 'âŒ', 'API ì—°ê²° ì‹¤íŒ¨: ' + error.message);
                }
            }

            // ëª¨ë‹¬ ê´€ë¦¬
            openModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.add('show');
                    document.body.style.overflow = 'hidden';
                }
            }

            closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('show');
                    document.body.style.overflow = '';
                }
            }

            // ìœ í‹¸ë¦¬í‹°
            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            async deleteWorkflow(workflowId) {
                if (!confirm('ì´ ì—…ë¬´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    return;
                }

                try {
                    // IndexedDBì—ì„œ ì‚­ì œ
                    const transaction = this.dbManager.db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    await new Promise((resolve, reject) => {
                        const request = store.delete(workflowId);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });

                    // ë©”ëª¨ë¦¬ì—ì„œ ì‚­ì œ
                    this.allData.workflows = this.allData.workflows.filter(w => w.id !== workflowId);
                    this.lastImportedWorkflowIds = this.lastImportedWorkflowIds.filter(id => id !== workflowId);

                    this.displayWorkflows();
                    this.showToast('success', 'âœ…', 'ì—…ë¬´ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
                } catch (error) {
                    console.error('ì—…ë¬´ ì‚­ì œ ì˜¤ë¥˜:', error);
                    this.showToast('error', 'âŒ', 'ì‚­ì œ ì‹¤íŒ¨: ' + error.message);
                }
            }

            // API í‚¤ ì•”í˜¸í™” (AES-GCM)
            async encryptApiKey(text) {
                if (!text) return '';
                try {
                    // ê³ ì • ì•”í˜¸í™” í‚¤ (32ë°”ì´íŠ¸ - AES-256ìš©)
                    const keyString = 'workflow-manager-api-key-2024-secret';
                    const keyBytes = new TextEncoder().encode(keyString.padEnd(32, '0').substring(0, 32));
                    
                    const key = await crypto.subtle.importKey(
                        'raw',
                        keyBytes,
                        { name: 'AES-GCM' },
                        false,
                        ['encrypt']
                    );
                    
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encoded = new TextEncoder().encode(text);
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encoded
                    );
                    
                    // IV + ì•”í˜¸í™”ëœ ë°ì´í„°ë¥¼ base64ë¡œ ì¸ì½”ë”©
                    const combined = new Uint8Array(iv.length + encrypted.byteLength);
                    combined.set(iv, 0);
                    combined.set(new Uint8Array(encrypted), iv.length);
                    
                    return btoa(String.fromCharCode.apply(null, combined));
                } catch (error) {
                    console.error('API í‚¤ ì•”í˜¸í™” ì˜¤ë¥˜:', error);
                    return text; // ì•”í˜¸í™” ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
                }
            }

            // API í‚¤ ë³µí˜¸í™” (AES-GCM)
            async decryptApiKey(encryptedText) {
                if (!encryptedText) return '';
                
                try {
                    // í‰ë¬¸ í‚¤ì¸ ê²½ìš° (ê¸°ì¡´ í˜¸í™˜ì„±) - base64 í˜•ì‹ì´ ì•„ë‹ˆê±°ë‚˜ ì§§ì€ ê²½ìš°
                    if (encryptedText.length < 20 || !encryptedText.match(/^[A-Za-z0-9+/=]+$/)) {
                        return encryptedText;
                    }
                    
                    const combined = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));
                    
                    // IVê°€ ì—†ìœ¼ë©´ í‰ë¬¸ìœ¼ë¡œ ê°„ì£¼
                    if (combined.length < 12) {
                        return encryptedText;
                    }
                    
                    const iv = combined.slice(0, 12);
                    const encrypted = combined.slice(12);
                    
                    // ê³ ì • ì•”í˜¸í™” í‚¤ (encryptApiKeyì™€ ë™ì¼)
                    const keyString = 'workflow-manager-api-key-2024-secret';
                    const keyBytes = new TextEncoder().encode(keyString.padEnd(32, '0').substring(0, 32));
                    
                    const key = await crypto.subtle.importKey(
                        'raw',
                        keyBytes,
                        { name: 'AES-GCM' },
                        false,
                        ['decrypt']
                    );
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encrypted
                    );
                    
                    return new TextDecoder().decode(decrypted);
                } catch (error) {
                    // ë³µí˜¸í™” ì‹¤íŒ¨ ì‹œ í‰ë¬¸ìœ¼ë¡œ ê°„ì£¼ (ê¸°ì¡´ í˜¸í™˜ì„± - Base64ë¡œ ì €ì¥ëœ ê²½ìš°)
                    try {
                        return atob(encryptedText);
                    } catch (e) {
                        return encryptedText;
                    }
                }
            }

            showToast(type, icon, message) {
                const toast = document.getElementById('toast');
                if (!toast) return;

                toast.textContent = `${icon} ${message}`;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // í”„ë¡œì íŠ¸ ë¬¸ì„œ ê°€ì ¸ì˜¤ê¸°
            async getProjectDocs(projectId) {
                try {
                    const docs = await this.dbManager.getPdfDocumentsByProject(projectId);
                    if (docs && docs.length > 0) {
                        return docs.map(doc => ({
                            filename: doc.filename,
                            content: doc.content,
                            parsedAt: doc.parsedAt,
                            pageCount: doc.pageCount,
                            summary: doc.summary
                        }));
                    }
                } catch (error) {
                    console.error('ë¬¸ì„œ ë¡œë“œ ì˜¤ë¥˜:', error);
                }
                return [];
            }

            // ê´€ë ¨ë„ ë†’ì€ ë¬¸ì„œ ì„ íƒ
            selectRelevantDocs(docs, checklistItems, maxCount = 1) {
                if (!docs || docs.length === 0) return [];
                if (docs.length <= maxCount) return docs;
                
                // í‚¤ì›Œë“œ ì¶”ì¶œ
                const keywords = this.extractKeywords(checklistItems);
                
                // ê´€ë ¨ë„ ê³„ì‚° ë° ì •ë ¬
                const docsWithScore = docs.map(doc => ({
                    doc: doc,
                    score: this.calculateRelevance(doc, keywords)
                }));
                
                // ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
                docsWithScore.sort((a, b) => b.score - a.score);
                
                // ìƒìœ„ ë¬¸ì„œ ë°˜í™˜
                return docsWithScore.slice(0, maxCount).map(item => item.doc);
            }

            // ë¬¸ì„œ ê´€ë ¨ë„ ê³„ì‚°
            calculateRelevance(doc, keywords) {
                if (!keywords || keywords.length === 0) return 0;
                if (!doc) return 0;
                
                let score = 0;
                const docText = (doc.filename || '') + ' ' + (doc.content || '') + ' ' + (doc.summary || '');
                const lowerDocText = docText.toLowerCase();
                
                keywords.forEach(keyword => {
                    const lowerKeyword = keyword.toLowerCase();
                    if (doc.filename && doc.filename.toLowerCase().includes(lowerKeyword)) {
                        score += 10;
                    }
                    if (doc.summary && doc.summary.toLowerCase().includes(lowerKeyword)) {
                        score += 5;
                    }
                    if (lowerDocText.includes(lowerKeyword)) {
                        score += 1;
                    }
                });
                
                return score;
            }

            // í‚¤ì›Œë“œ ì¶”ì¶œ
            extractKeywords(checklistItems) {
                if (!checklistItems || !Array.isArray(checklistItems)) return [];
                
                const keywords = new Set();
                
                checklistItems.forEach(item => {
                    if (!item || !item.text) return;
                    
                    const text = item.text;
                    const koreanNouns = text.match(/[ê°€-í£]{2,}/g);
                    if (koreanNouns) {
                        koreanNouns.forEach(noun => {
                            if (noun.length >= 2 && noun.length <= 10) {
                                keywords.add(noun);
                            }
                        });
                    }
                });
                
                return Array.from(keywords).slice(0, 20);
            }

            // ìŠ¤ë§ˆíŠ¸ ë¬¸ì„œ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
            async getSmartDocContext(doc, questionText, workflowId, apiKey, provider, model) {
                // ê¸°ì¡´ ìš”ì•½ì´ ìˆìœ¼ë©´ ì‚¬ìš©
                if (doc.summary && doc.summary.trim().length > 0) {
                    return doc.summary;
                }
                
                // ì§ˆë¬¸ì´ êµ¬ì²´ì ì¸ì§€ íŒë‹¨
                const isSpecificQuestion = questionText && (
                    questionText.includes('ì œ') && questionText.match(/\d+ì¡°/) ||
                    questionText.match(/\d+ì¼/) ||
                    questionText.length < 30
                );
                
                // êµ¬ì²´ì  ì§ˆë¬¸ì´ë©´ ê´€ë ¨ ë¶€ë¶„ ì¶”ì¶œ
                if (isSpecificQuestion && doc.content) {
                    const relevantText = this.extractRelevantText(doc.content, questionText, 2500);
                    if (relevantText.length > 200) {
                        return `[ì§ˆë¬¸ ê´€ë ¨ ë¶€ë¶„]\n${relevantText}`;
                    }
                }
                
                // ì¼ë°˜ ì§ˆë¬¸ ë˜ëŠ” ê´€ë ¨ ë¶€ë¶„ ì¶”ì¶œ ì‹¤íŒ¨: ì „ì²´ ë‚´ìš© ì‚¬ìš©
                return doc.content ? doc.content.substring(0, 2000) : '';
            }

            // ê´€ë ¨ í…ìŠ¤íŠ¸ ì¶”ì¶œ
            extractRelevantText(docContent, questionText, maxLength = 3000) {
                if (!docContent || !questionText) {
                    return docContent ? docContent.substring(0, maxLength) : '';
                }
                
                const keywords = this.extractKeywords([{ text: questionText }]);
                if (keywords.length === 0) {
                    return docContent.substring(0, maxLength);
                }
                
                // ë¬¸ì„œë¥¼ ë¬¸ë‹¨ ë‹¨ìœ„ë¡œ ë¶„í• 
                const paragraphs = docContent.split(/\n\n+/).filter(p => p.trim().length > 20);
                
                // ê° ë¬¸ë‹¨ì˜ ê´€ë ¨ë„ ì ìˆ˜ ê³„ì‚°
                const scoredParagraphs = paragraphs.map(para => {
                    let score = 0;
                    const lowerPara = para.toLowerCase();
                    
                    keywords.forEach(keyword => {
                        const lowerKeyword = keyword.toLowerCase();
                        const count = (lowerPara.match(new RegExp(lowerKeyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
                        score += count * 10;
                        
                        if (lowerPara.substring(0, 100).includes(lowerKeyword)) {
                            score += 20;
                        }
                    });
                    
                    return { text: para, score };
                });
                
                // ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
                scoredParagraphs.sort((a, b) => b.score - a.score);
                
                // ìƒìœ„ ê´€ë ¨ ë¬¸ë‹¨ë“¤ì„ ì„ íƒí•˜ì—¬ ê²°í•©
                let result = '';
                for (const para of scoredParagraphs) {
                    if (para.score === 0) break;
                    if (result.length + para.text.length > maxLength) {
                        const remaining = maxLength - result.length;
                        if (remaining > 100) {
                            result += para.text.substring(0, remaining) + '...\n\n';
                        }
                        break;
                    }
                    result += para.text + '\n\n';
                }
                
                // ê´€ë ¨ ë¶€ë¶„ì´ ì—†ê±°ë‚˜ ë„ˆë¬´ ì ìœ¼ë©´ ì „ì²´ ìš”ì•½ ì‚¬ìš©
                if (result.trim().length < 300) {
                    return docContent.substring(0, maxLength);
                }
                
                return result.trim();
            }
        }

        // ì•± ì´ˆê¸°í™”
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new MobileWorkflowManager();
            window.app = app;
        });

        // Service Worker ë“±ë¡ (PWA ì§€ì›)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // ìƒëŒ€ ê²½ë¡œ ì‚¬ìš© (GitHub Pages ì„œë¸Œ ë””ë ‰í† ë¦¬ ì§€ì›)
                const swPath = './service-worker.js';
                navigator.serviceWorker.register(swPath)
                    .then((registration) => {
                        console.log('âœ… Service Worker ë“±ë¡ ì„±ê³µ:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('âš ï¸ Service Worker ë“±ë¡ ì‹¤íŒ¨:', error);
                        // Service Worker ì‹¤íŒ¨í•´ë„ ì•±ì€ ì •ìƒ ì‘ë™
                    });
            });
        }
    </script>
</body>
</html>
